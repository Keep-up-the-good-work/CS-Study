# 1. HTTP와 HTTPS의 차이점에 대해 설명해주세요.
    - HTTP (HyperText Transfer Protocol)
        -> 서론 다른 시스템들 사이에서 통신을 주고받게 하는 가장 기본적인 프로토콜이다.
        -> 서버에서 브라우저로 데이터를 전송하는 용도로 가장 많이 사용한다.
            -> 서버에서 브라우저로 전송되는 정보가 암호화되지 않는 문제점이 있다.
        -> 주로 HTML 문서를 주고받는 데에 쓰인다.
        -> TCP와 UDP를 사용하며, 80번 포트를 사용한다.

        -> HTTP 동작 과정
            : 서버 접속 -> 클라이언트 -> 요청 -> 서버 -> 응답 -> 클라이언트 -> 연결 종료

    - HTTPS (HyperText Transfer Protocol Secure)
        -> HTTP에 SSL(보안 소켓 계층)을 사용한 프로토콜이다.
            -> SSL은 서버와 브라우저 사이에 안전하게 암호화된 연결을 만들 수 있도록 도와준다.
            -> 서버와 브라우저가 민감한 정보를 주고받을 때 해당 정보가 도난당하는 것을 막아준다.
            -> HTTPS의 기본 TCP/IP 포트로 443번 포트를 사용한다.

        -> HTTPS 동작 과정
            : 클라이언트가 서버에 접속하여 Handshaking 과정에서 서로 탐색 -> 데이터 전송 -> 연결 종료 및 session key 폐기
    
    => 금융 정보나 메일 등 중요한 정보를 주고받는 것은 HTTPS를, 아무나 봐도 상관 없는 페이지는 HTTP를 사용한다.
    => HTTPS 는 HTTP 자체를 암호화 하는 것이 아닌 HTTP Message Body를 암호화한다.
        -> 이때, HTTP Header는 암호화되지 않는다.
# 2. 쿠키와 세션의 차이점은 무엇인가요?
    - 쿠키 (Cookie)
        -> 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일이다.
        -> 이름, 값, 유효시간, 경로 등을 포함한다.
        -> 클라이언트의 상태 정보를 브라우저에 저장하여 참조한다.
        -> 동작 방식
            1. 클라이언트가 서버에 요청
            2. 상태를 유지하고 싶은 값을 쿠키로 생성
            3. 서버가 응답할 때 HTTP Header에 쿠키를 포함해서 전송(ex> Set-Cookie: id=doy)
            4. 전달받은 쿠키는 웹브라우저에서 관리하고 있다가, 다음 요청 때 쿠키를 HTTP Header에 넣어서 전송
            5. 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인 후 응답
        -> 쿠키 사용 예) 아이디,비밀번호 저장 / 쇼핑몰 장바구니

    - 세션 (Session)
        -> 일정 시간동안 같은 브라우저에서 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.
            => 즉, 웹 브라우저를 통해 서버에 접속한 이후부터 종료까지 계속해서 유지되는 상태이다.
        -> 동작 방식
            1. 클라이언트가 서버에 요청
            2. 서버가 해당 클라이언트에게 유일한 sessionId를 부여
            3. 서버가 응답할 때 HTTP Header에 sessionId를 포함해서 전송하고 쿠키에 해당 Id를 JSESSIONID 라는 이름으로 저장(ex> Set-Cookie: JSESSIONID=xlfej11f)
            4. 해당 클라이언트가 종료되기 전까지 부여된 sessionId가 담겨있는 쿠키를 HTTP Header에 넣어서 전송
            5. 서버는 sessionId를 확인하고, 해당 세션에 관련된 정보를 확인 후 응답
        -> 세션 사용 예) 로그인
        => 세션도 쿠키를 사용하여 값을 주고받으며 클라이언트의 상태 정보를 유지한다.
            즉, 상태 정보를 유지하는 수단은 쿠키 이다.

    
    => 쿠키와 세션의 차이점
        -> 저장 위치
            - 쿠키 : 클라이언트
            - 세션 : 서버
        
        -> 보안
            - 쿠키 : 클라이언트에 저장되므로 보안에 취약하다.
            - 세션 : 쿠키를 이용해 sessionId만 저장하고 해당 Id를 서버에서 구분하여 처리하므로 쿠키에 비해 비교적 좋다.

        -> 라이프사이클
            - 쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.
            - 세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간과 상관없이 삭제된다.

        -> 속도
            - 쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다.
            - 세션 : 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.

# 3. 서버의 부하를 분산하는 로드 밸런싱 기술에는 어떤 것이 있나요?
    - 로드 밸런서 (Load Balancer)
        -> 서버의 부하를 분산해주는 장치 또는 기술을 뜻한다.
        -> 보통 서버 상단 네트워크에 위치한다.
        -> 서버 한 대에 집중되지 않게 트래픽을 관리하여 각 서버가 최적의 효율을 발휘할 수 있게 해준다.

    - 로드 밸런서의 기본 기능
        -> Health Check
        -> 알고리즘에 따른 분산 처리
        -> NAT (Network Address Translation)
        -> DSR (Direct Server Return) / (Dynamic Source Routing) (?)

# 4. 비동기 처리를 위해 사용되는 기술에는 어떤 것이 있나요?
    - FE쪽
    
# 5. JWT(JSON Web Token)란 무엇인가요?
    - JWT는 aaaa.bbbb.cccc의 구조로 '.'을 구분자로 3가지의 문자열로 구성되어 있고,
      차례대로 헤더(Header), 내용(payload), 서명(signature)로 구성된다.

        - 헤더(Header)
            -> 헤더는 typ와 alg 두개의 정보를 지닌다.
                -> typ는 토큰의 타입을 지정하는데 JWT에는 "JWT"라는 값이 들어간다.
                -> alg는 해싱 알고리즘을 지정하는데 기본적으로 HMAC, SHA256, RSA가 사용되면,
                   토큰을 검증할 때 사용되는 signature 부분에서 사용된다.
            =>  {
                "typ" : "JWT"
                "alg" : "HS256"
                }
           
        
        - 정보(Payload)
            -> payload 부분에는 토큰을 담은 정보가 들어있다. 정보의 한 조각을 클레임(claim)이라 부르고,
               이는 name : value의 한 쌍으로 이루어져있다.
                -> 토큰에는 여러개의 클레임을 넣을 수 있지만 클레임이 많아질수록 토큰의 길이도 길어질 수 있다.
            -> claim의 종류
                1. registered claim
                    : 서비스에 필요한 정보들이 아닌 토큰에 대한 정보들을 담기 위해 이름이 이미 정해진 클레임들이다.
                2. public claim
                    : 충돌이 방지된 이름을 가지고 있어야 하며, 충돌 방지를 위하여 클레임 이름을 URI 형식으로 짓는다.
                3. private claim
                    : 클라이언트와 서버 합의 하에 사용되는 클레임 이름들이며,
                      public claim과는 달리 이름이 중복되어 충돌될 우려가 있어 유의해야 한다.


        - 서명(Signature)
            -> signature는 header의 인코딩값과 payload의 인코딩값을 합친 후 주어진 비밀키로 해쉬하여 생성한다.
               이렇게 해쉬를 base64형태로 나타내게 된다.

# 6. 메시지 브로커(Message Broker)란 무엇이며, 어떤 경우에 사용되나요?
    - 메시지 브로커는 publisher(송신자)로부터 전달받은 메시지를 subscriber(수신자)에게 전달해주는 역할을 한다.
    - 메시지를 주고 받는 역할을 하는 채팅 기능에 주로 사용하며, 대표적인 예로는 RabbitMQ, Kafka 등이 있다.

# 7. AWS(Amazon Web Services)와 GCP(Google Cloud Platform)의 차이점은 무엇인가요?
    - AWS 장점
        1. 가장 성숙한 클라우드 서비스 제공사
        2. 광범위한 서비스 및 파트너 생태계를 갖춘 시스템
        3. 가상 환경에서 모두 잘 실행되는 사용 사례들

    - AWS 단점
        1. 관리를 위해선 고급 전문 지식이 필요
        2. 강력한 하이브리드 클라우드 지원이 부족
        3. 파악하기 힘든 너무나 광범위한 서비스

    - GCP 장점
        1. 오픈 소스 커뮤니티에서 쌓은 놀라운 명성
        2. 분석 및 머신러닝에 대한 많은 투자
        3. 빅데이터 애플리케이션, ML 벤처 및 클라우드 네이티브 애플리케이션(어플리케이션 또는 서비스 시스템 관리를 컨테이너 기반 기술로 자동화한 환경)
           을 위한 최적의 옵션

    - GCP 단점
        1. 계약 협상에서 매우 엄격
        2. 소규모 파트너 생태계
        3. 대기업을 위한 제한된 범위의 서비스

    - 차이점
        -               AWS                                              GCP
            가격 : 시간당                                                분당
            컨테이너 : 도커, 쿠버네티스                                 쿠버네티스
            비용 : 컴퓨팅 및 스토리지 측면에서 조금 더 높다              AWS에 비해 저렴한 편
            객체 저장 : AWS S3                                        구글 클라우드 스토리지
            파일 저장 : AWS EFS                                       클라우드 파일 저장소
            볼륨 크기 : 500GB ~ 16TB                                  1GB ~ 64TB
            데이터 전송 형식 : 일반 형식                               완전히 암호화된 형식

    AWS : AWS에서는 패키지를 관리해야 하는 경우 외부 소프트웨어나 Artifactory와 같은 타사 소프트웨어를 통합 해야한다
    GCP : Artefact Registry에서 컨테이너 이미지 및 언어 패키지(예: Maven 및 npm)를 관리할 수 있다.
