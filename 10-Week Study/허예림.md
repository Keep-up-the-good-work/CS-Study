### 1. 연산 코드와 오퍼랜드에 대해서 설명해주세요.
> 연산코드와 오퍼랜드

명령어는 연산 코드와 오퍼랜드로 구성되어 있습니다. 연산 코드는 명령어가 수행할 연산을 의미하며 오퍼 랜드는 연산에 사용할 데이터의 위치 주소가 저장되어 있습니다. 연산 코드에는 데이터 전송, 산술 논리 연산, 제어 흐름 변경, 입출력 제어 등의 종류의 연산이 저장됩니다. 

### 2. 주소 지정 방식이 무엇인지 설명하고, 대표적인 주소 지정 방식 다섯 가지 나열하고 간략하게 설명해주세요
> 주소 지정 방식
- 주소 지정 방식
CPU에서 연산을 수행하기 위해 데이터의 위치를 알아야 한다. 따라서 명령어는 피연산자 필드를 이용하여 데이터의 위치에 대한 정보를 제공 한다. 주소 지정 방식은 피연산자 필드를 이용하여 데이터의 유효 주소를 결정하는 방법이다. 명령어에 담을 수 있는 비트 수에는 제한이 있기 때문에 최대한 효율적으로 데이터의 위치를 지정하는 다양한 주소 지정 방식이 사용된다. 

> 종류

  1. 직접 주소 지정 방식 : 명령어의 주소 필드의 내용이 유효 주소가 되는 방식입니다. 데이터의 인출을 위해 기억 장치를 한번만 접근하  나, 지정할 수 있는 기억 장치 주소 공간이 제한적이다. 
  2. 간접 주소 지정 방식 : 명령어의 주소 필드에 유효 주소가 저장되어 있는 방식이다. 두 번의 기억 장치 접근이 필요하며 기억 장치를 임의로 사용한다거나 프로그램상의 융퉁성을 발휘할 수 있다. 

### 3. 자바에서 추상 클래스와 인터페이스의 차이점은 무엇인가요?

> 추상 클래스

추상 메서드를 선언하여 상속을 통해 자손 클래스에 완성하도록 유도하는 클래스입니다. Class 앞에 abstract 키워드를 사용하여 정의하고, 상속을 위한 클래스 이기 때문에 따로 객체를 생성할 필요가 없습니다. 또 java에서는 다중 상속을 지원하지 않기 때문에 여러 개의 추상 클래스를 상속할 수 없습니다. 추상 메서드란 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨두는 것이 추상 메서드입니다. 상속 받는 클래스에 따라서 구현되는 내부 내용이 달라질 수 있습니다. 
> 인터페이스

추상 클래스가 미완성 설계도라면 인터페이스는 기본 설계도라고 할 수 있습니다. Interface 키워드를 사용하여 정의하는 인터페이스도 추상 클래스처럼 다른 클래스를 작성하는 데 도움을 주는 목적으로 작성하고 클래스와 다르게 다중상속이 가능합니다. 인터페이스는 추상 클래스보다 추상화 정도가 높으며 추상 클래스와는 다르게 구현부가 있는 일반 메서드, 일반 멤버 변수를 가질 수 없다는 특징이 있습니다. 
> 차이점

추상 클래스와 인터페이스의 공통점은 추상 메서드를 사용할 수 있다는 것입니다. 그럼 왜 굳이 2가지로 나누어 사용할까요? 추상 클래스와 인터페이스의 기능들을 살펴보면 추상 클래스가 인터페이스의 역할을 다 할 수 있지만 사용용도에 따라 큰 차이점이 있습니다. 추상 클래스는 extends 키워드를 사용하여 상속이 가능하지만, 다중 상속은 불가능 합니다. 인터페이스는 implements 키워드를 사용하여 상속하며, 다중 상속이 가능합니다. 때문에 자바의 특성상 한 개의 클래스만 상속이 가능하여 클래스의 구분을 추상 클래스 상속을 통해 해결하고, 공통된 기능을 인터페이스의 다중 상속을 통해 구현합니다.

### 4. String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.

> String

String은 불변성을 가지기 때문에 변하지 않는 문자열을 자주 읽어 들이는 경우 좋은 성능을 기대할 수 있습니다. 반면 문자열 추가, 수정, 삭제 등의 연산이 빈번하게 발생하는 알고리즘에 String 클래스를 사용하면 힙 메모리에 많은 임시 가비지가 생성되어 힙메모리가 부족으로 어플리케이션 성능에 치명적인 영향을 끼치게 됩니다. String 사용 시 초기에 선언했던 값을 다른 값으로 할당하게 되면 새로운 문자 데이터를 가지고 있는 새로운 문자영역을 가르키게 되고 처음 선언했던 값의 메모리 영역은 가비지로 남아있다가 GC에 의해 사라지게 됩니다. 즉, Stirng으로 선언된 변수의 문자 데이터가 변경되는 것이 아닌 새로운 String 인스턴스를 생성한 것입니다. 
> StringBuilder

String Builder는 가변성을 가지기 때문에 .append() .delete()등의 API를 이용하여 동일 객체내에서 문자열을 변경하는 것이 가능합니다. 
> StringBuffer

String Buffer 클래스는 내부적으로 버퍼라고 하는 독립적인 공간을 가지게 되며, 문자열을 바로 추가할 수 있어 공간의 낭비도 없으며 문자열 연산 속도도 매우 빠르다는 특징이 있습니다. 버퍼는 기본적으로 16개의 문자를 저장할 수 있는 크기를 가지며, 생성자를 통해 크기를 설정할 수 있습니다. String Buffer도 마찬가지로 가변성을 가지기 때문에 동일한 객체 내에서 문자열을 변경하는 것이 가능합니다. String Buffer는 동기화 키워드를 지원하기 때문에 멀티 쓰레드 환경에서의 안전성을 확보하고 있습니다. 

### 5. 중첩 루프 조인이 무엇인가요?
> 중첩 루프 조인

2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 row를 결합하여 원하는 결과를 조합하는 조인 방식입니다.
드라이빙 테이블로 한 테이블을 선정하고 이 테이블로부터 where절에 정의된 검색 조건을 만족하는 데이터들을 걸러낸 후, 이 값을 가지고 조인 대상 테이블을 반복적으로 검색하면서 조인 조건을 만족하는 최종 결과값을 얻어 냅니다. 드라이빙 테이블이란 JOIN을 할 때 먼저 Access 되어 ACCESS PATH를 주도하는 테이블을 Driving Table이라고 합니다. 여기서 Driving Table은 옵티마이저가 결정하고 자연스레 Driving Table이 아닌 테이블은 Driven Table로 결정 됩니다.
> 특징

주로 좁은 범위에서 유리하며 순차적 처리, Random Access 위주입니다. 후행 테이블에 조인을 위한 인덱스 생성이 필요합니다. 인덱스에 의한 랜덤 액세스에 기반하고 있기 때문에 대량의 데이터 처리 시 적합하지 않습니다. Drinven 테이블에는 조인을 위한 적절한 인덱스가 생성되어 있어야 합니다. 선행 테이블의 결과를 통해 후행 테이블을 액세스 할 때 랜덤 I/O가 발생합니다. 
### 6. 인덱스에 대해서 간략하게 설명하고, 사용방법에 대해서 설명해주세요.

> 인덱스

인덱스는 검색 연산의 최적화를 위해 데이터 베이스 내 값에 대한 주소 정보로 구성된 데이터 구조입니다. 인덱스를 활용하여 데이터를 빠르게 찾을 수 있으며 테이블에 대한 조회 속도를 높여주는 자료 구조입니다. 기본 키(PK) 컬럼은 자동으로 인덱스가 생성되며, 연월일이나 이름을 기준으로 하는 인덱스는 자동으로 생성되지 않습니다. 케이블의 컬럼에 인덱스가 없는 경우, 테이블의 전체 내용을 검색하게 되며 인덱스가 존재할 경우, 인덱스 범위를 스캔하여 데이터를 더 빠르게 찾을 수 있게 됩니다. 조건절에 “=”로 비교되는 컬럼을 대상으로 인덱스를 생성할 경우 검색 속도를 향상시킬 수 있습니다. 
> 사용방법

인덱스는 CREATE INDEX 명령어를 사용하여 생성할 수 있습니다. UNIQUE 명령어로 인덱스를 생성하는 컬럼에 중복 값을 허용하지 않도록 설정할 수 있습니다. CREATE INDEX 인덱스 명 뒤에 IN 테이블 명과 인덱스를 지정할 컬럼 명을 명시하여 생성합니다. TABLE과 마찬가지로 ALTER, DELETE 문을 사용하여 인덱스를 수정, 삭제할 수 있지만 기존 인덱스를 삭제하고 신규 인덱스를 생성하는 방식이 권고 되고 있습니다. 

### 7. 스프링 Bean의 생성 과정을 설명해주세요.

> Spring Bean

Spring IoC 컨테이너가 관리하는 자바 객체로서 컨테이너에 의해 생명주기가 관리되는 객체를 의미합니다. IoC 컨테이너 안에 들어있는 객체로 필요할 때마다 IoC 컨테이너에서 가져와서 사용합니다. 어노테이션 @Bean을 사용하거나 xml 설정을 통해 일반 객체를 Bean으로 등록이 가능합니다. Bean은 객체 생성, 의존 설정, 초기화, 사용, 소멸 과정의 생명 주기를 가지고 있습니다. 스프링 컨테이너가 초기화 될 때 먼저 빈 객체를 설정에 맞춰 생성하며 의존관계를 설정한 뒤 해당 프로세스가 완료되면 빈 객체가 지정한 메소드를 호출해서 초기화를 진행하게 됩니다. 객체를 사용해 컨테이너가 종료될 때 빈이 지정한 메서드를 호출해 소멸 단계를 거칩니다. 스프링 IntializingBean 인터페이스와 DisopsableBean을 제공하며 빈 객체의 클래스가 InitiallizingBean Interface 또는 DisposalBean을 구현하고 있으며 해당 인터페이스에 정의된 메소드를 호출해 빈 객체의 초기화 또는 종료를 수행합니다. 또한 어노테이션을 이용한 빈 초기화 방법에는 @PostConstruct와 빈소멸에는 PreDestory를 사용합니다. 
> 생성법

  1. Compent Scamming
ComponentScan 어노테이션과 @Comnent 어노케이션을 사용해 빈을 등록하는 방법입니다. @ComponentScan 어노테이션은 어느 지점부터 컴포넌트를 찾아야 하는 지를 명시하고 @Component는 실제로 찾아서 빈을 등록할 수 있는 클래스를 의미합니다. Spring IOC가 컨테이너에 IOC 컨테이너를 만들고 그 안에 빈을 등록할 때 사용하는 인터페이스들을 라이프 사이클 콜백이라고 부른다. 라이프 사이클 콜백 중 @Component 어노테이션을 찾아서 이 어노테이션에 붙어 있는 모든 클래스의 인스턴스를 생성해 빈으로 등록하는 작업을 수행하는 어노테이션 프로세서가 등록되어있습니다. 
  2.직접 빈을 등록하는 방법은 XML 혹은 자바 설정 파일을 작성하여 등록할 수 있습니다.
Configuration 어노테이션을 사용한 클래스를 생성 후 클래스 내부에 Bean 어노테이션을 사용하여 직접 빈을 생성할 수 있습니다. 빈을 직접 생성할 경우 Configuration 어노테이션이 Component 어노테이션을 사용하기 때문에 ComponentScan의 대상이 되고 그에 따라 빈 설정 파일이 읽힐 때 그 안에 정의한 빈들이 IoC  컨테이너에 등록되는 것입니다. 



### 8. JPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요.

1차 캐시 보장, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지, 지연 로딩 등이 있습니다. 

### 9. 그래프와 트리의 차이점은 무엇인가요? 
> 그래프

그래프는 노드와 노드 간을 연결하는 간선으로 구성된 자료구조이다. 이를 통해 연결된 노드 간의 관계를 표현할 수 있는 자료구조이다. 
> 그래프특징

1. 그래프는 순환 혹은 비순환 구조를 이룬다. 
2. 그래프는 방향이 있는 그래프와 방향이 없는 그래프가 있다. 
3. 루트 노드의 개념이 없다. 
4.부모-자식 관계라는 개념이 없다. 
5. 2개 이상의 경로가 가능하다. 
6. 그래프는 네트워크의 모델이다. 

> 트리

트리는 그래프와 같이 노드와 노드간을 연결하는 간선으로 구성된 자료구조이다. 그러나 트리는 그래프 중에서도 특수한 케이스에 해당하는 자료구조이다.
> 트리 특징

1. 트리는 방향이 있지만 사이클이 존재하지 않는 비순환 그래프이다. 
2. 부모 – 자식 관계라는 개념이 있으며 최상위에 Root 노드가 존재한다. 

> 차이점

트리는 방향이 있는 그래프만 있지만 그래프는 방향이 있거나 무방향일 수 있다. 또 트리는 비순환 그래프만 존재할 수 있지만 그래프는 순환, 비순환이 모드 가능하다. 루트 노드의 경우 트리에서 한 개의 루트 노드만이 존재하며 그래프는 루트 노드가 없습니다. 

### 10. gRPC는 무엇이며, RPC는 무엇인가요? 왜 쓸까요?
>RPC

Remote Procedure Call의 약자로 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게 하는 프로세스 간 통신 기술입니다. 쉽게 설명해서 MSA 구조로 서비스를 만들게 되면, 다양한 언어와 프레임워크로 개발되는 경우가 있는데, 이러한 구조에 RPC를 이용하여 언어에 구애받지 않고, 원격에 있는 프로시저를 호출하여 고유 프로그램의 개발에 집중할 수 있도록 해주는 기술입니다. 
> gRPC

GRPC는 구글에서 개발한 어느 환경에서도 실행할 수 있는 오픈 소스 고성능 RPC 프레임워크입니다. gRPC를 이용하여 원격에 있는 애플리케이션의 메서드를 로컬 메서드인 것처럼 직접 호출할 수 있기 때문에 분산 애플리케이션과 서비스를 보다 쉽게 만들 수 있습니다. 
