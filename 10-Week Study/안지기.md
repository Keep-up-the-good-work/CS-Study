### 1. 연산 코드와 오퍼랜드에 대해서 설명해주세요.

> 연산코드(연산자) - 연산 코드 필드
: 명령어가 수행할 연산
: 연산 코드의 종류는 매우 많지만, 가장 기본적인 연산 코드 유형은 크게 네가지로 나눌 수 있다.
: 1. 데이터전송
: 2. 산술/논리 연산
: 3. 제어 흐름 변경
: 4. 입출력 제어

> 오퍼랜드(피연산자) - 오퍼랜드 필드
: 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치
: 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터가 주소가 올 수 있다.
: 다만, 오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기보단 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다.
: 따라서, 주소 필드라고 부르기도한다.
: 오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 핸가 또는 두개, 세개 등 여러개가 있을 수도 있다.
: 여기서 오퍼랜드가 하나도 없는 명령어를 0-주소명령어, 하나는 1-주소명령어, 두개는 2-주소명령어, 세개는 3-주소명령어라고한다.

> 답변
: 연산코드와 오퍼랜드는 명령에 속하고 연산코드는 명령어가 수행할 연산을 뜻하면 크게 네가지로 데이터전송, 산술/논리 연산, 제어 흐름 변경, 입출력제어로 나눌 수 있다.
: 오퍼랜드는 연산에 사용할 데이터 또는 위치를 나타내며 오퍼랜드는 명령어 안에 하나도 없을수도 있고, 여러개가 있을 수 있으며, 주소필드라고 부르기도 한다.

### 2. 주소 지정 방식이 무엇인지 설명하고, 대표적인 주소 지정 방식 다섯 가지 나열하고 간략하게 설명해주세요

> 주소 지정 방식
: 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 주소 지정 방식이라고한다.
: 주소 지정 방식은 유효 주소를 찾는 방법이다.

> 즉시 주소 지정 방식
: 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식

> 직접 주소 지정 방식
: 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식

> 간접 주소 지정 방식
: 유효 주소의 주소를 오퍼랜드 필드에 명시

> 레지스터 주소 지정 방식
: 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법

> 레지스터 간접 주소 지정 방식
: 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법

> 답변
: 연산에 사용할 데이터 위치를 찾는 방법을 주소 지정 방식이라고하며, 즉시 주소 지정 방식은 연산에 사용할 데이터를 명시하고
: 직접 주소 지정 방식은 유효 주소(메모리 주소)를 명시하고
: 간접 주소 지정 방식은 유효 주소의 주소를 명시하며
: 레지스터 주소 지정 방식은 : 유효 주소(레지스터 이름)을 명시
: 레지스터 간접 주소 지정 방식 : 유효 주소를 저장한 레지스터를 명시한다.

### 3. 자바에서 추상 클래스와 인터페이스의 차이점은 무엇인가요?

> 추상 클래스(abstract method)
: 메서드의 본체가 완성되지 않은 미완성 메서드
: 추상 메서드를 1개 이상 포함하고 있는 클래스는 반드시 추상 클래스로 정의돼어야한다.
: 추상 클래스는 내부의 미완성 메서드 때문에 객체를 직접 생성할 수 없다.
: 힙 메모리에 생성되는 객체는 내부 요소가 미완성된 상태로 들어갈 수 없기 때문이다.

> 인터페이스()
: 인터페이스는 내부의 모든 필드가 public static final로 정의도고, static과 default 메서드 이외의 모든 메서드는 public abstract로 정의된 객체지향 프로그래밍 요소이다.
: 

> 메서드의 완성과 미완성의 구분 기준
: 메서드의 기능을 정의하는 중괄호의 존재 여부로 알 수 있음
: 만일 중괄호 안에 아무런 코드가 없다면 그 메서드는 '아무런 일도 하지 말라'고 기능이 명확히 정의된 완성된 메서드이다.

> 오버라이딩(Overriding)
: 완성된 메서드이든, 미완성된 메서드이든 부모에게 상속받은 메서드를 자식 클래스에서 재정의하는 것을 통칭한다.

> 구현한다(Implements)
: 부모에게 물려받은 미완성 메서드를 자식 클래스에서 완성하는 것

> 답변
: 추상 클래스는 추상 메서드와 구현된 메서드를 모두 가질 수 있지만, 인터페이스는 추상 메서드만을 가질 수 있고 구현된 메서드를 가질 수 없다. 
: 클래스는 추상 클래스를 상속받을 수 있지만 다중 상속이 불가능하며, 인터페이스는 다중 상속이 가능

### 4. String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.

> String
: String 클래스는 불변(immutable)입니다. 즉, 한 번 생성되면 그 값을 변경할 수 없습니다.
: 문자열의 연결, 검색, 추출 등의 작업을 수행할 수 있습니다.
: String 인스턴스는 새로운 문자열이 생성될 때마다 새로운 메모리 공간에 저장됩니다.
: 동기화(synchronization)가 보장되지 않아 멀티스레드 환경에서 안전하지 않을 수 있습니다.

> StringBuilder
: StringBuilder 클래스는 가변(mutable)입니다. 즉, 생성된 이후에도 값을 변경할 수 있습니다.
: 문자열의 동적인 연결이나 수정 작업을 수행할 때 사용됩니다.
: StringBuilder는 단일 스레드 환경에서 성능이 우수합니다.
: 동기화가 보장되지 않아 멀티스레드 환경에서 안전하지 않을 수 있습니다.

> StringBuffer
: StringBuffer 클래스는 가변(mutable)이며, 문자열의 연결 및 수정 작업을 수행하는 데 사용됩니다.
: StringBuilder와 마찬가지로 동적인 문자열 조작에 적합합니다.
: StringBuffer는 멀티스레드 환경에서 동기화가 보장됩니다.
: 멀티스레드 환경에서 안전하게 사용할 수 있지만, 단일 스레드 환경에서는 StringBuilder보다 성능이 느릴 수 있습니다.


### 5. 중첩 루프 조인이 무엇인가요?

> 중첩 루프 조인
: 두 개 이상의 테이블을 조인할 때, 중첩된 반복문을 사용하여 다차원 데이터 구조를 탐색하는 방식
: 여러 테이블 간의 관계를 분석하고 조인 조건에 따라 데이터를 결합

### 6. 인덱스에 대해서 간략하게 설명하고, 사용방법에 대해서 설명해주세요.

> 인덱스
: 데이터베이스에서 테이블의 검색 성능을 향상시키기 위해 사용되는 데이터 구조
: 인덱스는 특정 열 또는 열의 조합에 대한 정렬된 값 목록으로, 데이터를 빠르게 검색하고 효율적으로 필터링할 수 있도록 도와줍니다
: 테이블의 열 중 검색 빈도가 높거나 조인 조건으로 자주 사용되는 열에 인덱스를 생성하는 것입니다. 
: 인덱스는 데이터의 변경 작업(삽입, 갱신, 삭제)에는 약간의 오버헤드가 발생하므로 적절한 열에 인덱스를 생성해야 합니다.

### 7. 스프링 Bean의 생성 과정을 설명해주세요.

> 스프링 Bean의 생성 과정
: Bean의 정의: 스프링 컨테이너에 Bean을 생성하고 관리하기 위해 먼저 Bean의 정의가 필요합니다. Bean의 정의는 XML 파일, Java Configuration 클래스 또는 주석을 사용하여 작성할 수 있습니다.

: Bean의 인스턴스화: 스프링 컨테이너는 Bean의 정의를 기반으로 Bean의 인스턴스를 생성합니다. 이 단계에서는 클래스의 기본 생성자를 사용하여 인스턴스를 생성하거나, 팩토리 메서드를 통해 인스턴스를 생성할 수도 있습니다.

: 의존성 주입: 스프링은 Bean의 의존성을 주입하는 기능을 제공합니다. 의존성 주입은 스프링 컨테이너가 Bean의 의존하는 다른 Bean을 자동으로 주입하여 의존성을 해결하는 과정입니다. 이를 통해 Bean 간의 결합도를 낮추고 유연한 구성을 가능하게 합니다.

: 초기화: Bean이 생성되고 의존성이 주입된 후, 스프링은 Bean의 초기화를 수행합니다. 초기화 메서드를 사용하여 Bean을 설정하거나 초기 데이터를 로드하는 등의 작업을 수행할 수 있습니다.

: 사용: Bean의 초기화가 완료되면, 해당 Bean은 스프링 컨테이너에서 사용할 수 있습니다. 다른 Bean이나 컴포넌트에서 해당 Bean을 참조하고 사용할 수 있습니다.

: 소멸: 스프링 컨테이너가 종료되거나 Bean이 더 이상 필요하지 않을 때, 해당 Bean은 소멸될 수 있습니다. 이때 Bean의 소멸 메서드를 호출하여 리소스를 정리하거나 종료 작업을 수행할 수 있습니다.

### 8. JPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요.

>  JPA 영속성 컨텍스트의 이점(5가지)
: 1차 캐시: 영속성 컨텍스트는 1차 캐시를 제공하여 데이터베이스에서 가져온 엔티티를 메모리에 저장합니다. 이를 통해 동일한 엔티티에 대한 반복적인 조회를 최소화하고, 성능을 향상시킬 수 있습니다.

: 지연 로딩: 영속성 컨텍스트는 연관된 엔티티를 필요할 때까지 실제로 로딩하지 않고, 프록시 객체를 사용하여 지연 로딩을 지원합니다. 이를 통해 필요한 데이터만 로딩하여 데이터베이스에서 가져오는 횟수를 최소화하고, 성능을 향상시킵니다.

: 변경 감지: 영속성 컨텍스트는 엔티티의 상태 변화를 감지하여 자동으로 데이터베이스에 반영합니다. 변경된 엔티티만을 식별하여 업데이트 쿼리를 실행하므로, 변경된 데이터만을 데이터베이스에 저장하고, 성능을 최적화할 수 있습니다.

: 트랜잭션 범위 관리: 영속성 컨텍스트는 트랜잭션 범위 내에서 엔티티의 영속성을 관리합니다. 따라서, 트랜잭션이 커밋되기 전까지 엔티티의 변경 사항을 추적하고, 롤백 시에는 변경 사항을 취소할 수 있습니다.

: 쓰기 지연: 영속성 컨텍스트는 쓰기 지연을 지원합니다. 변경된 엔티티를 즉시 데이터베이스에 반영하지 않고, 트랜잭션이 커밋되기 전까지 대기합니다. 이를 통해 여러 개의 변경 작업을 한 번에 실행하여 데이터베이스 호출 횟수를 줄이고, 성능을 향상시킵니다.

### 9. 그래프와 트리의 차이점은 무엇인가요? 

> 차이점
: 사이클 여부: 그래프는 사이클을 가질 수 있지만, 트리는 사이클을 가지지 않습니다. 사이클은 그래프에서 노드들이 순환 경로를 형성하는 것을 말합니다. 트리는 계층적인 구조를 가지며, 한 노드에서 다른 노드로 이동할 때 사이클이 발생하지 않습니다.

: 루트 노드와 부모-자식 관계: 트리는 하나의 루트 노드를 가지며, 다른 모든 노드는 루트로부터 직간접적으로 연결됩니다. 또한, 트리에서 각 노드는 하나의 부모 노드와 여러 개의 자식 노드를 가질 수 있습니다. 그래프는 루트 노드가 필요하지 않으며, 노드 간에 임의의 연결이 가능합니다.

: 방향성: 그래프는 간선에 방향성이 있을 수 있고, 양방향으로 이동할 수 있습니다. 반면에 트리는 모든 간선이 단방향으로 향하며, 노드 간의 방향성이 정해져 있습니다.

: 노드 연결 수: 그래프는 임의의 수의 노드들이 연결될 수 있습니다. 노드 간의 관계는 자유롭게 형성될 수 있습니다. 트리는 각 노드마다 최대 하나의 부모와 여러 개의 자식을 가질 수 있습니다.

: 계층 구조: 트리는 계층적인 구조를 가지고 있으며, 부모와 자식 관계를 통해 데이터를 조직화합니다. 그래프는 일반적으로 순서나 계층이 없는 비선형 구조를 가집니다.

### 10. gRPC는 무엇이며, RPC는 무엇인가요? 왜 쓸까요?

> gRPC
: gRPC는 Google에서 개발한 오픈 소스의 고성능 원격 프로시저 호출(Remote Procedure Call) 프레임워크

> RPC
: RPC는 네트워크를 통해 분산 시스템에서 서로 다른 프로세스나 컴퓨터 간에 메시지를 교환하고, 원격으로 함수나 프로시저를 호출하는 기술을 의미

> 사용이유
: 편의성: RPC는 마치 로컬 함수 호출처럼 원격 함수 호출을 수행할 수 있습니다. 개발자가 복잡한 네트워크 통신 코드를 작성하지 않고도 원격 서비스를 간편하게 호출할 수 있습니다.

: 분산 시스템 통합: RPC를 사용하면 분산 시스템 간의 통신을 쉽게 구축할 수 있습니다. 다른 언어나 플랫폼에서 작동하는 서비스 간에 상호 작용할 수 있으며, 다양한 프로그래밍 언어를 지원하는 gRPC를 통해 개발자는 다양한 클라이언트와 서버를 구현할 수 있습니다.

: 성능: gRPC는 Protocol Buffers를 사용하여 데이터 직렬화를 수행하므로, 데이터 크기를 최소화하고 직렬화/역직렬화의 성능을 향상시킵니다. 또한, 양방향 스트리밍과 같은 고급 기능을 제공하여 대량의 데이터를 효율적으로 처리할 수 있습니다.

: 확장성: gRPC는 HTTP/2 프로토콜을 기반으로 작동하며, 다양한 플랫폼과 언어에서 지원되는 장점을 가지고 있습니다. 또한, 인터셉터와 같은 기능을 사용하여 요청 및 응답을 처리하고, 인증 및 보안 등의 고급 기능을 추가할 수 있습니다.


