
### 1. Java 의 메모리 구조에 대해서 설명해보세요.
> - 스택(Stack) 영역: 메서드 호출 시에 사용되는 지역변수와 매개변수, 그리고 메서드의 수행과 관련된 임시 데이터를 저장합니다. 스택은 후입선출(LIFO) 구조를 따르며, 메서드가 호출될 때마다 프레임(Frame)이라는 작은 메모리 블록이 생성되어 스택에 쌓입니다. 메서드가 종료되면 해당 프레임이 스택에서 제거됩니다.
>   - 스택(stack) 영역은 자바 프로그램에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역입니다. 
>   - JVM은 자바 프로그램에서 메소드가 호출되면, 메소드의 호출과 관계되는 지역 변수와 매개변수를 스택 영역에 저장합니다. 
>   - 이렇게 스택 영역은 메소드의 호출과 함께 할당되며, 메소드의 호출이 완료되면 소멸합니다. 
>   - 이렇게 스택 영역에 저장되는 메소드의 호출 정보를 스택 프레임(stack frame)이라고 합니다. 
>   - 스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.


> - 힙(Heap) 영역: 객체와 배열이 생성되는 영역으로, 동적으로 할당됩니다. 힙 영역에 생성된 객체는 Garbage Collector가 관리하며, 더 이상 사용되지 않는 객체는 자동으로 제거됩니다.
>   - 힙(heap) 영역은 자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역입니다.
>   - JVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙 영역에 저장합니다.
>   - 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.


> - 메서드 영역(Method area 또는 클래스 영역): 클래스 정보와 같은 클래스 수준의 정보를 저장합니다. 이 영역은 JVM이 시작할 때 생성되며, 모든 스레드가 공유합니다.
>   - 메소드(method) 영역은 자바 프로그램에서 사용되는 클래스에 대한 정보와 함께 클래스 변수(static variable)가 저장되는 영역입니다. 
>   - JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일(*.class)를 읽어들여, 해당 클래스에 대한 정보를 메소드 영역에 저장합니다.


Java의 메모리 구조는 스택, 힙, 메서드 영역으로 나누어진다.

스택 영역에서는 메서드 호출 시 사용되는 지역변수와 매개변수 메서드의 수행과 관련된 임시 데이터를 저장한다.

힙 영역에서는 객체와 배열이 생성되는 영역이고 동적으로 할당된다 (가비지 관리)

메서드 영역에서는 클래스 정보와 같은 클래스 수준의 정보가 저정된다.

### 2. 웹 서버와 애플리케이션 서버의 차이점은 무엇인가요?
> - 웹 서버 (Web Server), 혹은 WAS(Web Application Server)
> - 이미지와 같은 고정된 데이터를 제공 하거나(웹 서버) 동적으로 매번 새로운 데이터를 만들어 낼 수 있는 
> WAS(실제 운영 환경에서는 보통 웹 서버와 WAS를 분리해서 운영하지만, 대부분의 WAS는 웹 서버 기능도 겸하고 있다)
> - 웹 서버는 HTTP 프로토콜을 사용하여 클라이언트로부터 요청을 받아 정적인 웹 페이지, 이미지, CSS, JavaScript 파일 등을 제공하는 역할을 합니다. 대표적인 웹 서버로는 Apache, Nginx, IIS 등이 있으며, 이들 웹 서버는 정적인 콘텐츠를 제공하는 데에 특화되어 있습니다.
> - 애플리케이션 서버는 웹 서버보다 더 복잡한 로직을 수행하는 애플리케이션을 실행하고 관리하는 서버입니다. 애플리케이션 서버는 다양한 기술과 프레임워크를 사용하여 빠르고 안정적인 웹 애플리케이션을 개발하고 배포할 수 있도록 지원합니다. 예를 들어, 애플리케이션 서버는 서블릿(Servlet)과 JSP(JavaServer Pages)를 사용하여 동적인 콘텐츠를 생성하며, EJB(Enterprise JavaBeans)와 JMS(Java Message Service)를 사용하여 엔터프라이즈 애플리케이션을 개발하고 배포할 수 있습니다. 

웹 서버는 정적인 콘텐츠를 제공하는데 특화되어 있습니다.

애플리케이션 서버는 웹 서버보다는 더 복잡한 로직을 수행하는 애플리케이션을 실행하고 관리하는 서버입니다.

#### WAS에서 Web Server역할이 가능한데 분리해서 사용할까?
> 자원 사용의 효율성 및 장애극복, 배포 및 유지보수의 편의성을 위해 사용된다.
- 기능을 분리하여 서버 부하를 방지한다.
  - WAS는 DB 조회, 다양한 로직을 수행하기라 바쁘기 때문에 단순한 정적 컨텐츠는 Web Server에서 빠르게 클라이언트한테 제공하는 것이 좋다.
  - 정적 컨텐츠 요청까지 WAS에서 수행하게 되면 부하가 커지게 되고, 동적 컨텐츠 처리가 지연됨에 따라 수행속도가 느려진다.
- 물리적으로 분리하여 보안을 강화시킨다.
  - SSL 대한 암복호화 처리에 Web Server를 사용
- 여러 대의 WAS를 연결해 로드 밸런싱 용도로 사용할 수 있다.
  - Fail over, Fail back 처리에 유리하다.
  - 대용량 웹 어플리케이션의 경우, Web Server와 WAS를 분리하여 오류가 발생한 WAS를 사용하지 않고, 다른 WAS를 사용하게 만듦으로써 무중단 운영을 가능하게 한다.
- 여러 언어의 웹 어플리케이션 서비스가 가능하다.
  - 하나의 서버에서 PHP Application, Java Application를 함께 사용하는 등과 같이 여러 웹 어플리케이션의 활용이 가능해진다.
  - 톰캣은 Java언어만 해석이 가능하다. JSP 같은 경우, 처리가 가능하지만 PHP는 실행이 불가능하다. 고로, Web server로 아파치를 사용해 PHP를 사용할 수 있게 만들 수 있다.


### 3. 클러스터링과 로드밸런싱의 차이점은 무엇인가요?
> - 클러스터링은 여러 대의 서버를 하나의 클러스터(Cluster)로 묶어서 하나의 시스템처럼 동작하게 하는 기술
> - 클러스터링은 여러 대의 서버를 하나의 논리적 단위로 관리함으로 가용성 및 성능 향상, 확장성, 그리고 장애 대응 능력을 개선할 수 있다.
> - 로드 밸런싱은 여러 대의 서버에 걸쳐 분산되는 네트워크 트래픽을 조절하여 서버의 부하를 분산하는 기술
> - 로드밸런서는 클라이언트로부터 들어오는 요청을 여러 대의 서버로 분산하여 처리하는 역할을 한다.

로드밸런서는 네트워크의 트래픽을 조절하여 서버에 분산하는것이고, 

클러스터링은 여러 대의 서버를 하나의 단위로 묶어 시스템처럼 동작하게 하는것이다.

로드 밸런싱은 단일 서버에 대한 요청을 여러 대의 서버에 고르게 분산시키는 것으로, 부하를 분산하여 성능을 향상시키는 개념입니다. 

클러스터링은 여러 대의 시스템을 하나의 시스템으로 구성하여 가용성과 확장성을 향상시키는 개념입니다. 

> 로드 밸런싱은 주로 서버 간의 작업 부하를 분산하는 데 중점을 둔 반면, 클러스터링은 시스템 자체를 구성하는 방식이므로 전체 시스템의 아키텍처에 영향을 줍니다.

### 4. ORM 에 대해서 설명해보세요.
> - ORM은 객체 지향적인 코드를 사용하여 데이터베이스를 조작할 수 있게 해줍니다
> - ORM(Object-Relational Mapping)은 객체 지향 프로그래밍과 관계형 데이터베이스 사이의 불일치를 해결하기 위한 기술로, 객체와 데이터베이스 테이블 간의 매핑을 자동으로 처리
> - ORM 프레임워크는 객체와 데이터베이스 사이의 매핑 정보를 설정하고, 자동으로 SQL을 생성하여 데이터베이스를 조작
> - ORM을 사용하면 개발자가 직접 SQL을 작성하지 않아도 되므로, 생산성이 향상되고 유지보수가 쉬워집니다
> - ORM은 다양한 언어와 프레임워크에서 지원되며, 대표적으로는 Java에서는 Hibernate, Spring Data JPA, MyBatis 등이 있고, Python에서는 Django ORM, SQLAlchemy 등이 있습니다
> - https://gmlwjd9405.github.io/2019/02/01/orm.html


### 5. Spring DI 에 대해 설명해보세요.
> - Spring DI(Dependency Injection)는 객체간의 의존성을 외부에서 설정하는 기술로, 객체 지향 프로그래밍에서 중요한 개념 중 하나
> - DI는 객체를 생성하고 조립하는 것을 컨테이너가 수행하도록 하여, 객체 간의 결합도를 낮추고 유연성과 확장성을 높인다.
> - Constructor Injection: 생성자를 이용하여 의존성을 주입하는 방법입니다. 생성자 인자를 통해 의존하는 객체를 전달받아 필드에 할당합니다. 
> - Setter Injection: Setter 메소드를 이용하여 의존성을 주입하는 방법입니다. Setter 메소드를 호출하여 필드에 의존하는 객체를 할당합니다. 
> - Field Injection: 필드를 직접 주입하는 방법입니다. @Autowired 어노테이션을 이용하여 의존하는 객체를 할당합니다.

스프링에서 다른 프레임워크와 차별화되어 제공하는 의존 관계 주입 기능
객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입 시켜주는 방식
DI(의존성 주입)를 통해서 모듈간의 결합도가 낮아지고 유연성이 높아진다.
스프링에서는 객체를 Bean이라고 부르며, 프로젝트가 실행될때 사용자가 Bean으로 관리하는 객체들의 생성과 소멸에 관련된 작업을 자동적으로 수행해주는데,
객체가 생성되는 곳을 스프링에서는 Bean컨테이너라고 부른다.
> - https://velog.io/@gillog/Spring-DIDependency-Injection

### 6. 프로세스와 스레드에 대해서 설명해보세요.
> - 프로세스(Process)는 운영체제에서 실행 중인 프로그램을 말한다.
> - 프로세스는 실행 중인 프로그램의 코드, 데이터, 스택, 힙 등의 메모리 영역과 실행 상태 등의 정보를 가지고 있습니다
> - 프로세스는 운영체제의 자원을 할당받아 독립적으로 실행
> - 프로세스 간의 통신을 위해서는 운영체제가 제공하는 IPC(Inter-Process Communication) 기술을 사용해야 한다.
> - 스레드(Thread)는 프로세스 내에서 실행되는 작업의 단위
> - 스레드는 프로세스의 자원(메모리, 파일 등)을 공유하면서 실행
> - 각각의 스레드는 독립적인 실행 경로를 가지고 있지만, 프로세스의 메모리 영역을 공유하기 때문에 스레드간의 데이터 공유가 쉽다.
> - 스레드를 사용하면 프로세스 내에서 병렬적으로 작업을 처리할 수 있어서 성능이 향상된다.
> - 프로세스는 독립성이 높아서 안정성이 높고, 스레드는 경량화되어 있어서 처리 속도가 빠릅니다
> - https://swjeong.tistory.com/127

### 7. 쓰레드의 통신 방식 시 어떤 문제가 있는지 설명해보세요
> - https://popcorntree.tistory.com/84
> - https://iredays.tistory.com/125
> - 스레드 간의 통신은 공유 자원에 대한 접근 문제 때문에 문제가 발생할 수 있다.
> - 두 스레드가 동시에 같은 자원에 접근하여 데이터가 손상되거나 예기치 않는 결과가 발생할 수 있다.경쟁 상태 (Race Condition)
> - 동기화 기법을 사용해 해결
>   - 뮤텍스(Mutex)
>   - 세마포어(Semaphore)
>   - 모니터(Monitor)

### 8. JPA N + 1 문제 발생 원인과 해결방법에 대해 말씀해주세요
> - 연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 된다
> - JPA에서 @OneToMany 나 @ManyToOne 어노테이션 옵션 중 fetch = FetchType.LAZY 옵션을 설정해주면 됩니다.
> - Lazy 로딩은 필요할 때만 데이터를 가져오기 때문에 성능 이슈를 해결할 수 있습니다
> - etch Join 이라는 기능을 이용하여 한 번에 필요한 데이터를 모두 가져올 수 있습니다. 이 방법은 JPQL의 JOIN FETCH 구문을 사용합니다. 이를 사용하면 SQL 조인을 이용해 모든 데이터를 한 번에 가져오기 때문에 N+1 문제를 해결할 수 있습니다
> - Batch Size 를 이용하여 한 번에 가져올 데이터 수를 조정할 수 있습니다. Batch Size 는 @BatchSize 어노테이션을 이용하여 설정하며, 설정한 만큼 데이터를 한 번에 가져오게 됩니다. 이를 통해 N+1 문제를 해결할 수 있습니다.
> - https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1
> - https://programmer93.tistory.com/83
> - 실무에서 N+1문제로 DB가 죽어버리는 문제를 방지하기 위해서는 어떻게 해야 할까?
    우선 연관관계에 대한 설정이 필요하다면 FetchType을 성능 최적화를 하기 어려운 즉시 로딩(EAGER)을 사용하는 게 아니라 지연 로딩 (LAZY) 모드로 사용을 하고 성능 최적화가 필요한 부분에서는 Fetch 조인을 사용한다.
    또한 기본적으로 Batch Size의 값을 1000 이하로 설정한다. (대부분의 DB에서 IN절의 최대 개수 값 : 1000)
그 외에 팀바팀이긴 한데 꼭 연관관계 설정이 필요 없다면 N+1 문제로 인하여 DB가 죽어버리는 불상사를 막기 위해 연관관계를 끊어버리고 사용하는 것도 방법이다.

### 9. HashMap vs LinkedHashMap 차이와 장단점
> - HashMap은 key-value 쌍을 저장하는데 사용된다.
> - 내부적으로는 비교적 간단한 해시 함수를 사용하기 때문에 메모리 사용량이 작습니다
> - 순서를 보장하지 않기 때문에 순서에 의존하지 않는 검색에 적합합니다. 
> - HashMap은 순서를 보장하지 않는다.
> - 삽입 순서와 상관없이 key-value 쌍을 저장한다. 
> - 삽입, 조회, 삭제 연산 모두 O(1)의 시간 복잡도를 가집니다.
> - 하지만 삽입 순서를 기억하지 않기 때문에 순서에 의존하는 경우에는 부적합합니다.
> - LinkedHashMap은 HashMap과 같이 해시 함수를 이용하여 키를 해시코드로 매핑한다.
> - 엔트리의 삽입 순서를 기억한다.
> - LinkedHashMap은 삽입 순서대로 순회할 수 있으며, 이를 이용하여 LRU 캐시를 구현하는 데에 유용
> - 삽입, 조회, 삭제 연산 모두 O(1)의 시간 복잡도를 가집니다.
> - 삽입 순서를 기억하기 때문에 순서에 의존하는 검색에 적합합니다.
> - 해시 테이블과 연결 리스트를 모두 사용하기 때문에 메모리 사용량이 더 많습니다.
> - 하지만 순서를 기억하기 때문에 LRU 캐시를 구현하는 데에 유용합니다.

### 10. 병목 현상이 발생하는 이유와 해결 방법은 무엇인가요?
> - 병목 현상은 시스템 내에서 성능이 떨어지는 원인 중 하나
> - 시스템 내의 하드웨어 자원이 부족 or 하드웨어 자원을 공유하는 다른 프로세스 또는 스레드와 경쟁하는 경우
> - 프로그램 내에서 잘못된 알고리즘을 사용 or 데이터 구조가 비효율적으로 설계되어 있는 경우에도 병목 현상이 발생
> - 해결 방법
>   - 시스템 자원의 부족으로 인한 병목 현상인 경우
>     - 하드웨어 자원을 추가로 구매하거나, 다른 하드웨어 자원을 사용하여 부하를 분산시키는 등의 방법
>     - 그램 내에서 알고리즘을 최적화하거나, 데이터 구조를 재설계하여 효율적인 처리를 할 수 있도록 개선
>   -  프로파일링 도구를 사용하여 프로그램의 성능을 분석하고, 병목 현상이 발생하는 원인을 파악
>     - CPU 사용률이 매우 높은 경우에는 CPU-bound 문제로 인한 병목 현상이 발생
>     - 디스크 I/O가 많은 경우에는 I/O-bound 문제로 인한 병목 현상이 발생
> - 병목 현상을 해결하기 위해서는 시스템 자원을 최적화하거나, 알고리즘과 데이터 구조를 개선하고, 프로파일링 도구를 사용하여 문제를 파악하는 등 다양한 방법을 적절히 활용
