### 1. JDK 와 JRE, JVM 의 차이에 대해서 설명해보세요.
> JDK(Java Development Kit)는 Java 언어로 애플리케이션을 개발하기 위해 필요한 도구들의 집합입니다. 
> - JDK에는 Java 컴파일러(javac)와 같은 도구들, Java 프로그램을 실행하기 위한 실행 파일(java), 디버깅 도구(jdb), API 문서 및 개발 도구 등이 포함되어 있습니다. 
> - JDK는 개발자가 Java 언어로 작성한 소스 코드를 컴파일하고 실행 가능한 애플리케이션으로 변환하는 데 사용됩니다. 따라서 JDK는 Java 애플리케이션 개발에 필수적인 도구입니다.

> JRE(Java Runtime Environment)는 Java 애플리케이션을 실행하기 위한 실행 환경입니다. 
> - JRE는 JVM과 Java 클래스 라이브러리들로 구성되어 있습니다.

> JVM은 Java 바이트 코드를 기계어로 변환하여 실행하는 가상 머신입니다. 
> - JRE는 JVM과 Java 클래스 라이브러리들을 포함하고 있어서, Java 애플리케이션이 다른 운영 체제나 컴퓨터에서도 실행될 수 있도록 합니다. 
> - JRE는 개발자가 작성한 Java 애플리케이션을 실행하기 위해 필요한 최소한의 요구 사항을 갖추고 있습니다.

#### JDK는 Java 개발 도구들의 집합으로 애플리케이션 개발에 사용되며, 
#### JRE는 Java 애플리케이션을 실행하기 위한 실행 환경으로 JVM과 Java 클래스 라이브러리들을 포함하고 있습니다. 
#### JVM은 JRE 내에서 Java 애플리케이션의 실행을 담당하는 가상 머신입니다.


### 2. DI 와 IoC 에 대해서 설명해보세요.
> #### DI(Dependency Injection)와 IoC(Inversion of Control)는 소프트웨어 개발에서 의존성 관리와 객체 생성/조립에 관련된 개념

> 의존성 주입(Dependency Injection, DI)은 객체 간의 의존 관계를 외부에서 정의하고 주입하는 디자인 패턴
> - 일반적으로 객체는 다른 객체와 상호작용을 위해 의존성을 가지게 됩니다. 
> - 이 의존성을 생성자 인수, 메서드 매개변수, 또는 프로퍼티로 전달하는 방식으로 의존성 주입이 이루어집니다. 
> - 의존성 주입을 통해 객체는 자신이 필요로 하는 의존 객체를 직접 생성하거나 찾을 필요 없이 주입받아 사용할 수 있습니다. 
> - 이를 통해 객체 간의 결합도를 낮출 수 있고, 유연하고 테스트 가능한 코드를 작성할 수 있습니다.


>  제어의 역전(Inversion of Control, IoC)은 프로그램의 제어 흐름을 개발자가 아닌 프레임워크나 컨테이너에 위임하는 개념
> - 일반적으로 개발자가 코드 내에서 객체를 생성하고 관리하는 제어 흐름을 가지지만, 
> - IoC 컨테이너는 객체의 생성과 관리를 담당하고 개발자는 컨테이너에 필요한 정보를 제공하는 방식으로 작업을 수행합니다. 
> - 이는 객체의 생명 주기와 의존성 관리를 개발자가 아닌 외부에서 제어하게 되는 것을 의미합니다. 
> - IoC를 통해 애플리케이션의 모듈성, 재사용성, 유지보수성을 향상시킬 수 있습니다.


DI는 의존성을 주입받는 디자인 패턴으로 객체 간의 결합도를 낮추고 유연성과 테스트 용이성을 높입니다. 

IoC는 제어 흐름을 개발자가 아닌 외부 컨테이너에 위임하여 애플리케이션의 객체 생성과 관리를 담당하며, 
이를 통해 모듈성과 유지보수성을 향상시킬 수 있습니다. 

DI는 IoC를 실현하는 한 가지 방법으로, 외부에서 의존성을 주입받는 방식으로 객체 간의 결합도를 낮춥니다.


### 3. 데이터베이스 정규화에 대해서 설명해보세요.
> 정규화는 데이터를 여러 개의 테이블로 분리하는 과정이다. 이를 통해 중복된 데이터를 제거하고 데이터를 논리적으로 그룹화하는 작업을 한다. 보통 1차 정규화부터 5차 정규화까지 총 5단계로 나뉘며, 각 단계에서는 특정 조건을 만족하는 속성들을 테이블로 분리합니다.
> - 1차 정규화에서는 모든 속성이 원자값(Atomic value)을 가져야 한다. 
> - 2차 정규화에서는 기본키를 제외한 모든 속성이 기본키에 대해 완전 함수적 종속(Fully functional dependency)을 가져야 합니다.
> - 3차 정규화에서는 기본키를 제외한 모든 속성이 기본키에 대해 이행적 함수적 종속(Transitive functional dependency)이 아니어야 합니다.
> - 4차 정규화에서는 다중 값 종속(Multi-valued dependency)을 처리한다. 
> - 5차 정규화에서는 조인(JOIN) 분해를 통해 중복을 제거합니다.

정규화는 데이터베이스 설계시 반드시 고려되어야 하는 중요한 개념 중 하나이며, 데이터베이스를 최적화하는 데 중요한 역할한다.
데이터 중복을 최소화하여 데이터 일관성을 유지하고 성능을 향상시키는 과정입니다.

### 4. map과 list의 차이에 대해서 설명해보세요.
>  List는 일련의 요소들을 저장하며, 각 요소는 인덱스를 통해 접근됩니다. 따라서 요소들 간의 순서가 중요한 경우 List를 사용한다. 
>  또한, List는 중복된 값을 포함할 수 있으므로, 같은 값이 여러 번 나타날 수 있습니다. 
>  List에는 여러 가지 구현 방식이 있으며, 가장 일반적으로 사용되는 것은 ArrayList와 LinkedList가 있다. 

> Map은 key-value 쌍으로 데이터를 저장하는 데이터 구조입니다. 
> 키는 고유한 값이며, 값은 키에 연관된 데이터를 나타냅니다. 
> 키를 사용하여 값을 찾는 데 매우 효율적이며, 키는 중복될 수 없습니다. 
> Map은 여러 가지 구현 방식이 있으며, 가장 일반적으로 사용되는 것은 HashMap, TreeMap, LinkedHashMap 등이 있다.

List는 순서가 있는 데이터를 저장하며, 중복된 값을 포함할 수 있습니다.
Map은 키-값 쌍으로 데이터를 저장하며, 각 키는 유일하고 중복된 키를 포함할 수 없습니다.
List는 각 요소에 대한 반복문을 사용하여 처리할 수 있고, Map은 키-값 쌍에 대한 반복문을 사용하여 처리할 수 있습니다.

### 5. CORS(Cross-Origin Resource Sharing)란 무엇인가요?
> CORS는 Cross-Origin Resource Sharing의 약자로, 웹 브라우저에서 발생하는 보안 상의 이슈인 Same-Origin Policy를 우회하기 위한 웹 표준이다.
> Same-Origin Policy는 웹 브라우저가 보안을 위해 적용하는 규칙으로, 하나의 출처(origin)에서 로드된 문서나 스크립트에서 다른 출처로의 요청을 제한하는 것
> 웹 애플리케이션에서 다른 도메인으로의 API 요청이 필요한 경우 Same-Origin Policy에 따라 요청이 차단된다.
> CORS는 이러한 문제를 해결하기 위해, 브라우저에서 다른 출처의 리소스에 접근할 때, 서버에서 발행한 헤더를 사용하여 요청에 대한 권한을 부여하도록 하는 것이다.
> 서버는 Access-Control-Allow-Origin이라는 헤더를 응답에 추가하여, 허용된 도메인으로부터의 요청만을 허용하게 된다.

> CORS는 웹 애플리케이션에서 다른 출처의 리소스에 접근할 때 발생하는 보안상의 문제를 해결하기 위한 방법 중 하나입니다. 이를 허용하기 위해, 웹 서버는 HTTP 응답 헤더를 통해 요청에 대한 권한을 부여합니다. 

> CORS를 사용하려면, 클라이언트(브라우저)와 서버 간에 미리 정해진 규칙이 있어야 합니다. 클라이언트가 다른 출처의 리소스에 접근하려면, 서버는 특정 헤더(예: "Access-Control-Allow-Origin")를 응답 헤더에 추가하여 요청을 허용해야 합니다. 이 헤더는 허용된 출처(origin)를 명시하며, *로 설정하면 모든 출처를 허용합니다. 

> 또한, 클라이언트에서는 요청 헤더에 "Origin"이라는 키를 사용하여 요청하는 출처를 전달해야 합니다. 서버는 이 출처를 확인하여, 허용된 출처인지를 판단합니다. 만약 허용된 출처이 아니라면, 서버는 "Access-Control-Allow-Origin" 헤더를 포함하지 않은 응답을 반환하며, 클라이언트는 이를 차단합니다. 

> CORS는 보안상의 이유로 기본적으로 브라우저에서 적용되는 기능이므로, 서버 측에서 헤더를 설정하는 것 외에도 클라이언트 측에서도 몇 가지 주의할 점이 있습니다. 예를 들어, XMLHttpRequest를 사용하여 요청할 때에는 withCredentials를 true로 설정해야 합니다. 또한, JSONP나 iframe을 사용한 요청 등은 CORS를 우회할 수 있는 방법 중 하나이므로, 이에 대해서도 유의해야 합니다.

CORS는 다른 출처의 리소스에 접근할 때 발생하는 보안 문제를 해결하기 위한 웹 표준이며, 웹 서버에서 HTTP 응답 헤더를 통해 권한을 부여하고 클라이언트는 요청 헤더에 출처 정보를 전달한다.

### 6. 서버리스 아키텍처란 무엇인가요?
> 서버리스 아키텍처는 서버가 없거나 서버를 구축하고 관리하는 것이 아닌, 클라우드 기반의 플랫폼에서 코드를 실행하는 방식이다
> 클라우드 서비스 제공 업체가 서버 프로비저닝, 스케일링 및 유지 관리와 같은 작업을 처리하므로 개발자는 인프라를 관리할 필요 없이 코드를 작성하고 실행할 수 있습니다
> 버리스 아키텍처를 사용하면 개발자는 서비스를 더욱 쉽게 개발, 테스트 및 배포할 수 있으며, 비용도 기존 방식보다 효율적으로 관리할 수 있다

> 서버리스 아키텍처는 마이크로서비스, 함수 기반 컴퓨팅, 이벤트 기반 아키텍처 등 여러 기술들을 사용하여 클라우드 환경에서 구현할 수 있습니다. 
> 이를 통해 개발자는 인프라와 관련된 문제에 대해 걱정하지 않아도 되고, 코드 개발에 집중할 수 있습니다. 
> 서버리스 아키텍처는 높은 확장성과 가용성, 자동화된 관리, 더 빠른 개발 주기, 비용 효율성 등의 장점을 제공합니다. 
> 이러한 이점들은 특히 인터넷 기반 서비스 및 모바일 애플리케이션 분야에서 매우 중요합니다.

서버리스 아키텍처는 클라우드 환경에서 실행되는 코드 기반의 서비스 아키텍처로, 
서버 인프라를 구축하거나 관리하지 않고 개발자가 코드를 작성하고 실행할 수 있도록 합니다. 
이를 통해 개발자는 인프라 관리에 대한 부담을 덜 수 있으며, 더욱 빠르고 효율적인 서비스를 제공할 수 있습니다.


### 7. 백엔드 개발에서 TDD(Test-Driven Development)를 사용하면 어떤 장점이 있나요?
> TDD(Test-Driven Development)는 소프트웨어 개발 방법론 중 하나로, 테스트를 먼저 작성한 후 그에 맞는 코드를 작성하는 개발 방식이다
> 이를 통해 개발자는 테스트 코드를 통해 요구사항에 대한 이해도를 높이고, 안정적이며 유지보수성이 좋은 코드를 작성할 수 있다.
> TDD는 개발 프로세스를 더욱 체계적이고 안정적으로 만들어주며, 리팩토링 작업을 더욱 쉽고 안전하게 수행할 수 있게 한다.
> TDD는 백엔드 개발에서 매우 중요한 역할을 하며, 테스트 자동화, 지속적인 통합 등과 함께 소프트웨어 개발의 효율성을 높이는 방법 중 하나입니다.

> TDD(Test-Driven Development)를 사용하면 어떤 장점
> - 코드 품질 향상: TDD는 테스트 코드를 먼저 작성하고 이에 맞게 코드를 작성하므로, 안정적이고 품질이 높은 코드를 만들 수 있습니다. 
> - 버그 감소: TDD를 사용하면 테스트 케이스를 작성하여 코드를 테스트하므로, 버그를 발견하고 이를 미연에 방지할 수 있습니다. 
> - 유지보수 용이: TDD는 코드의 유지보수성을 향상시키며, 리팩토링 작업을 쉽고 안전하게 수행할 수 있습니다. 
> - 요구사항 충족: TDD는 개발자가 요구사항에 대한 이해도를 높이는데 도움을 줍니다. 테스트 케이스를 작성하면서 요구사항에 대한 정확한 이해를 할 수 있고, 요구사항을 충족하는 코드를 작성할 수 있습니다. 
> - 개발 시간 단축: TDD는 초기에 문제를 발견하고 이를 해결하므로, 개발 시간을 단축할 수 있습니다. 또한 테스트 자동화를 통해 반복적인 작업을 자동화하므로, 개발 시간을 더욱 단축할 수 있습니다.


TDD(Test-Driven Development)는 테스트 코드를 먼저 작성하고, 이에 맞게 코드를 작성하는 개발 방법론입니다. TDD를 사용하면 코드 품질이 향상되고, 버그가 감소하며, 유지보수성과 요구사항 충족도가 향상되며, 개발 시간을 단축할 수 있습니다.

### 8. 백엔드에서 데이터베이스를 설계할 때 고려해야 할 요소는 무엇인가요?
> 데이터베이스를 설계할 때 고려해야 할 요소 
> - 데이터 모델링: 데이터 모델링은 데이터베이스 설계의 기본이며, 데이터의 구조와 관계를 결정하는 과정입니다. 데이터 모델링을 통해 데이터의 구조를 잘 설계함으로써 데이터베이스의 성능과 유지보수성을 높일 수 있습니다.
> - 정규화: 정규화는 데이터를 구조화하여 중복을 제거하고 데이터의 일관성과 무결성을 보장하는 방법입니다. 데이터를 일관성 있게 구조화하면 데이터베이스의 성능을 향상시키고, 데이터의 무결성을 유지할 수 있습니다.
> - 인덱싱: 인덱싱은 데이터베이스에서 데이터를 빠르게 검색하고, 조회할 수 있도록 해주는 방법입니다. 적절한 인덱싱을 통해 데이터베이스의 성능을 향상시킬 수 있습니다. 
> - 보안: 데이터베이스는 중요한 정보를 보관하므로, 보안이 매우 중요합니다. 데이터베이스에 접근 권한을 효율적으로 관리하고, 보안에 취약한 쿼리를 방지하여 데이터의 무결성과 기밀성을 보장해야 합니다. 
> - 확장성: 데이터베이스 설계는 애플리케이션의 확장성을 고려해야 합니다. 데이터베이스의 성능을 높이는 방법을 고려하고, 새로운 요구사항이나 기능 추가를 고려하여 설계를 해야 합니다. 또한, 데이터베이스의 용량이나 성능이 부족할 경우 확장을 고려해야 합니다. 
> - 백업과 복구: 데이터베이스는 중요한 정보를 보관하므로, 데이터베이스의 백업과 복구 방법을 고려해야 합니다. 데이터 유실을 방지하고, 비상 대응을 위한 백업과 복구 계획을 수립하여 데이터베이스의 안정성을 유지해야 합니다.

백엔드에서 데이터베이스를 설계할 때 고려해야 할 요소는 다양하다. 먼저 데이터 모델링을 통해 데이터를 추상화하고 구조화해야 하며, 이를 위해 엔티티와 속성, 관계 등을 정의해야 한다. 또한, 정규화를 통해 데이터 중복을 최소화하고 일관성을 유지해야 한다. 이뿐만 아니라 인덱싱을 통해 데이터 접근 속도를 개선하고, 데이터의 보안, 성능, 확장성 등 다양한 측면에서 설계를 고려해야 한다. 이러한 요소들은 데이터베이스의 효율적인 운영과 개발, 그리고 시스템의 성능과 보안을 보장하기 위해 중요하다.

### 9 . 백엔드에서 사용되는 프로세스 간 통신(IPC) 방법은 무엇이 있나요?
> IPC는 Inter-Process Communication의 약자로, 프로세스 간에 데이터를 주고받는 기술을 의미합니다

> - 파이프(Pipe)를 사용하는 방법
>   - 파이프는 단방향 통신만 가능하다. 
>   - 부모 프로세스와 자식 프로세스 간의 통신에 주로 사용된다. 
>   - 파이프는 유닉스 운영체제에서 기본적으로 제공되는 IPC 기법 중 하나이다. 
>   - 메모리를 사용하지 않기 때문에 컴퓨터 자원을 적게 사용합니다. 
>   - 하지만, 파이프는 양방향 통신을 지원하지 않기 때문에 데이터를 주고받는 데에 있어서는 다소 불편함이 있을 수 있다.

> - 소켓(Socket)을 사용하는 방법
>   - 소켓은 네트워크를 통해 다른 서버와 통신할 때 주로 사용되는 IPC 기법이다. 
>   - 소켓은 TCP/IP 프로토콜을 기반으로 동작하며, 양방향 통신이 가능하다. 
>   - 소켓은 인터넷을 통해 서버와 클라이언트가 통신할 때 주로 사용된다. 
>   - 멀리 떨어져 있는 서버와도 통신이 가능하다. 
>   - 하지만, 소켓은 다른 IPC 기법에 비해 사용하기가 조금 복잡합니다.

> - 공유 메모리(Shared Memory)를 사용하는 방법
>   - 공유 메모리는 여러 프로세스가 같은 메모리 공간을 공유하여 데이터를 주고받을 때 사용하는 IPC 기법이다. 
>   - 공유 메모리는 데이터를 복사하지 않고 메모리 공간을 공유하기 때문에 빠른 속도로 데이터를 전송할 수 있다. 
>   - 하지만, 공유 메모리를 사용할 때는 여러 프로세스가 동시에 메모리에 접근할 수 있기 때문에 동기화 이슈가 발생할 수 있다.

백엔드에서 사용되는 프로세스 간 통신(IPC) 방법은 크게 3가지로 나눌 수 있습니다. 첫 번째는 파이프(Pipe)를 사용하는 방법으로, 부모 프로세스와 자식 프로세스 간의 통신에 많이 사용됩니다. 두 번째는 소켓(Socket)을 사용하는 방법으로, 네트워크를 통해 다른 서버와 통신할 때 주로 사용됩니다. 마지막으로, 공유 메모리(Shared Memory)를 사용하는 방법으로, 여러 프로세스가 같은 메모리 공간을 공유하여 데이터를 주고받을 때 사용됩니다. 

### 10. 백엔드에서 사용되는 OAuth2.0이란 무엇이며, 어떤 상황에서 사용하는 것이 적합한가요
> OAuth 2.0은 클라이언트 애플리케이션이 사용자의 인증 및 권한 부여를 처리하기 위한 프로토콜이다.
> OAuth 2.0은 사용자 정보에 대한 액세스를 요청하는 애플리케이션과 인증서버 또는 ID 공급자 간의 상호작용을 지원한다.
> OAuth 2.0은 사용자 비밀번호를 공유하지 않으며, 대신 사용자는 애플리케이션에서 인증서버 또는 ID 공급자로 이동하여 인증하고, 애플리케이션은 인증 서버 또는 ID 공급자로부터 액세스 토큰을 받아 사용자 정보를 요청한다.
> OAuth2.0은 인증 및 인가 프로토콜로, 제3자 애플리케이션에서 사용자 데이터에 안전하게 액세스할 수 있도록 해줍니다. 
> OAuth2.0은 클라이언트, 리소스 소유자, 인가 서버, 리소스 서버 간의 상호 작용을 기반으로 합니다. 
> OAuth2.0 프로토콜은 여러 종류의 권한 부여(flows)를 제공하며, 클라이언트가 리소스 서버에 직접 액세스하지 않고 인가 서버를 통해 액세스합니다. 
> OAuth2.0을 사용하면 개인 정보 보호와 보안을 유지하면서 다른 서비스에서 안전하게 사용자 데이터를 공유할 수 있습니다.

> OAuth 2.0은 인증 및 권한 부여를 위한 개방형 표준 프로토콜이다. 이 프로토콜은 클라이언트 애플리케이션이 서드 파티 서비스(소셜 미디어, 클라우드 저장소 등)에 접근할 수 있도록 허용하며, 사용자의 데이터에 대한 보안과 개인 정보 보호를 유지하면서 인증 및 권한 부여를 처리한다.

> OAuth 2.0은 사용자를 인증하는 과정에서 리소스 서버와 인증 서버를 구분하고, 클라이언트 애플리케이션이 인증 서버에 사용자 인증을 요청하여 인증 코드를 받은 후 이를 사용하여 엑세스 토큰을 발급받는 방식으로 동작한다. 이때, 액세스 토큰은 클라이언트 애플리케이션이 리소스 서버에 요청하는 모든 API에 대한 권한 부여를 제공한다.

OAuth2.0은 사용자 인증 및 권한 부여 프레임워크로, 인증 서버를 통해 인증을 수행하고, 인증된 사용자가 다른 애플리케이션에서 API에 대한 접근 권한을 부여 받을 수 있게 해줍니다. OAuth2.0은 외부 서비스를 사용하는 다른 애플리케이션에서 로그인 정보를 공유하고 권한을 부여할 수 있기 때문에 많은 애플리케이션에서 사용됩니다. 예를 들어, 사용자가 Facebook 계정으로 로그인하여 다른 애플리케이션에서 Facebook API를 사용할 수 있게 하는 경우가 있습니다. 따라서 OAuth2.0은 다른 서비스의 API를 사용하는 경우에 적합합니다.