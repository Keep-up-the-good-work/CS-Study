## 1. JDK 와 JRE, JVM 의 차이에 대해서 설명해보세요.

>JDK란?
  
 JDK는 Java Development Kit의 약자로 자바 개발 시 여러 기능을 제공하는 키트입니다. JDK는 JRE를 포함하고 있고, JRE는 JVM을 포함하고 있습니다. JDK는 자바의 소스코드 파일을 바이트코드로 변환하는 Javac와 javac가 만든 클래스 파일을 해석 및 실행하는 java, 자바 디버깅 툴인 jdb, jre, jvm 등으로 구성되어 있습니다. 종류에는 Java SE, JAVA EE, JAVA ME 등이 있습니다.
 1. Java SE에서 SE는 Standard Edition으로 이름 그대로 표준 자바 플랫폼입니다. 표준적인 컴퓨팅 환경을 지원하기 위한 자바 가상머신 규격 및 API 집합을 포함하고 있습니다. 자바의 핵심 기능을 제공하고 있습니다. 주요 패키지로는 Java.lang.*, java.io.*, java.util.*, java.awt.*, javax.rmi.*, javax.net.*등이 있습니다.
 2. JAVA EE는 Entertprise Edition으로 Java Se에 웹 애플리케이션 서버에서 동작하는 기능을 추가한 플랫폼입니다. 구체적인 목적에 따라 자바 SE를 기반으로 API를 추가하거나 자바 가상머신 규격 및 API의 일부를 택하여 정의합니다. JAVA EE의 스펙에 따라 제품을 구현한 것을 WAS라고 합니다.
 3. JAVA ME 는 Micro Edition으로 제한된 자원을 가진 환경에서 자바를 지원하기 위해 만든 플랫폼입니다.

>JRE란?

JRE란 Java Runtion Environment의 약자로 자바 런타임 환경을 의미합니다. 자바 클래스 라이브러리, 자바 가상 머신, 자바 클래스 로더를 포함하고 있습니다. JVM이 원활히 작동할 수 있도록 실행환경을 맞춰주는 역할을 수행합니다. 작성된 자바 코드를 JVM에 넘겨 실행시키는 일을 한다고 볼 수 있습니다.   

>JVM이란?

JVM이란 java Virtual Machin의 약자로 자바 가상 머신을 의미합니다. 자바를 모든 운영체제 위에서도 실행할 수 있게 하며, 자바 프로그램 상 메모리를 관리하고 최적화하는 역할을 수행합니다.

## 2. DI 와 IoC 에 대해서 설명해보세요.

> DI란?

 DI dependency Injection이란 의존성 주입으로 객체를 주입 받는 것을 의미합니다. 메서드나 객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입시키는 방법입니다. 스프링에서 외부는 스프링 컨테이너를 의미하며 객체에서 필요한 객체를 스프링 컨테이너로부터 주입 받는 것입니다. 예를 들어 A 객체에서 B,C 객체를 직접 생성할 경우 A는 B,C 객체를 의존하게 됩니다. 만약 B,C 객체가 변경 될 경우 A도 수정해야 됩니다. 이때 B,C 객체를 외부에서 생성 후 주입시켜 생성자를 통해 사용할 경우 A는 B,C 객체를 의존하고 있지 않기 때문에 B,C 객체가 수정이 되어도 영향을 미치지 않게 됩니다. 따라서 직접 객체를 생성하는 것에 비해 의존도와 결합도가 낮아집니다. 스프링에서는 객체는 Bean이라고 부르며, 프로젝트가 실행 될 때 사용자가 Bean으로 관리하는 객체들의 생성과 소멸에 관련된 작업을 자동적으로 수행해주는데 객체가 생성되는 곳을 Bean 컨테이너라고 부릅니다. 의존성 주입 방식에는 Field Injection, Setter Injection, Constructor Injection등이 있습니다. 
 1. Field Injection: 의존성을 주입해야 하는 필드에 @Autowired 어노테이션을 붙이는 방식입니다. 주입 받으려는 빈의 생성자를 호출하여 빈을 조회/등록하고, 생성자 인자에 사용하는 빈을 찾거나 만들고 필드에 주입하게 되는 방식입니다. 
 2. Setter Injection: setter 메소드에 @Autowired 어노테이션을 붙여 의존성을 주입하는 방식입니다. 주입 받으려는 빈의 생성자를 호출하여 빈을 조회/등록하고 생성자 인자에 사용하는 빈을 조회/생성 후 주입하려는 빈 객체의 수정자를 호출하여 주입하게 되는 방식입니다. 
 
 3.Constructor Injection: 생성자를 사용하여 의존성을 주입하는 방식입니다. 생성자의 인자에서 사용되는 빈을 조회/등록 합니다. 조회 한 인자 빈으로 주입하려는 생성자를 호출합니다. 

> IOC란 ?

IOC란 Inversion of control로 제어의 역전을 의미하며 메소드나 객체의 호출작업을 외부에서 결정하는 것을 의미합니다. 객체의 의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드를 작성할 수 있게 하여 가독성 및 코드 중복, 유지 보수를 편하게 할 수 있게 합니다.
스프링에서 스프링이 제어권을 가지고 생성 및 관계를 부여하는 객체를 빈이라고 부르고, 빈들의 생성과 관계 설정을 담당하는 IoC 객체를 빈 팩토리, 애플리케이션 컨텍스트라 합니다. 빈을 생성하고 제어하는 관점에서 정의하면 빈 팩토리라는 용어를 사용하고, 좀 더 크고 넓은 관점에서 애플리케이션 전체를 관리하는다는 의미로 정의하면 애플리케이션 컨텍스트라는 용어를 사용합니다.


## 3.데이터베이스 정규화에 대해서 설명해보세요.

> 정규화란?

데이터 베이스 정규화란 관계형 데이터 베이스 설계 시 데이터 모델의 중복을 최소화 하도록 데이터를 구조화 하고, 데이터의 일관성 및 유연성을 확보하기 위한 목적으로 데이터를 분해하는 과정입니다. 데이터 베이스 정규화를 통해 규모가 크고 이상이 있는 관계를 재구성하여 잘 조직된 여러 개의 테이블로 나누는 것이 목표입니다. 정규화의 단계가 높아질수록 이상현상은 줄어들게 됩니다.

> 목적?
  
  1. 불필요한 데이터를 제거하고, 데이터의 중복을 최소화 함으로써 저장공간이나 자원을 효율적으로 사용하기 위함 
  2. 삽입/갱신/삭제 시 발생할 수 있는 이상 현상을 제거하기 위함
  3. 정규화된 데이터 베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
  4. 데이터 베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되어 응용프로그램의 생명을 연장시킨다.

## 4. map과 list의 차이에 대해서 설명해보세요.
> map이란?
 
 키와 값을 한 쌍으로 이루어지는 데이터의 집합 키에 대한 중복이 없으며 순서를 보장하지 않습니다. 뛰어난 검색 속도를 가집니다. 키의 검색 속도에 따라 달라질 수 있습니다. 인덱스가 따로 존재하지 않기 때문에 iterator를 사용합니다. 
종류에는 Hash Map, HaspTable, LinkdeHashmap이 있습니다.
  1. hashMap : 키에 대ㅏㄴ 중복이 없으며 순서를 보장하지 않는다., 키에 대한 중복이 없으며 순서를 보장하지 않는다. 키와 ㄱ벨류 값으로 널을 허용한다. 동기ㅘ가 보장되지 않는다. 검색에서 가장 뛰어난 성능을 가진다.
  2. Hash Table : 동기화가 보장되어 병렬 프로그래밍이 가느아고 HashMap보다 처리 속도가 느리다. 키와 값으로 Null을 허용하지 않는다.
  3. LinkeHashMap : 입력된 순서를 보장한다. 
  4. TreeMap : 이진 탐색 트리를 기반으로 키와 값을 저장한다. 키값을 기준으로 오름차순 정렬되고 빠른 검색이 가능하다. 저장 시 정렬을 하기 때문에 다소 오래 걸린다. 


> list란?

순서가 있고 중복을 허용한다. 인덱스로 원소에 접근이 가능합니다, 크기가 가변적입니다
원하는 데이터가 뒤쪽에 있는 경우 속도의 문제.
종류 linkedlist, ArratList 등이 있습니다.
  1. Linekedlist : .양방향 포인터 구조로 데이터 삽입, 삭제가 빠르다, ArrayList보다 검색이 느리다,”
  2. Arratlist : 단방향 포인터 구조로 데이터 순차적 접근에 강점을 가진다. 배열을 기반으로 데이터를 저장한다. 데이터 삽입, 삭제가 느리다. 데이터 검색이 빠르다. 

> 차이점 

Map은 키와 값을 한쌍으로 가지는 데이터 집합으로 인덱스가 없고, 키에 대한 중복을 허용하지 않는 자료구조입니다. 순서를 보장하지 않는다는 특징이 있습니다. 반면에 List는 순서를 보장하고, 중복을 허용하는 자료구조 입니다. 인덱스를 가지고 있기 때문에 인덱스를 사용하여 원소를 접근할 수 있고 가변적이라는 특징을 가지고 있습니다.  

## 5.CORS(Cross-Origin Resource Sharing)란 무엇인가요?
> CORS란?

Cross Origin Resource Sharing의 약자로 동일한 출처가 아닌 다른 출처의 데이터를 주고 받는 것을 허용하는 정책입니다. 동일 출처 정책에 의하면 다른 출처에서 리소스를 받아오는 것이 제한됩니다. 이 문제를 해결하기 위해 나온 것이 CORS 입니다. CORS의 방법으론 단순 요청 방법과 예비 요청 방법이 있습니다. 요청은 요청하는 헤더와 응답하는 헤더를 통해 이루어지게 됩니다. 요청 헤더는 요청을 할 때 어떤 메서드를 사용할 것인지 알려주는 것입니다(Access-Control-Request-Method), 요청할 때 어떤 헤더를 사용할 것인지 알려주는 것입니다. (Access-Control-Request-Headers) 요청할 때 어떠한 헤더를 사용할 것인지 알려주는 것입니다.
 
## 6.서버리스 아키텍처란 무엇인가요?
> 서버리스 아키텍처란?

특정 작업을 수행하기 위해서 컴퓨터 혹은 가상머신 서버를 설정하고, 이를 통하여 처리하는 것이 아닌 구조를 의미합니다. 사실 상 작업을 처리하는 서버는 존재하지만 서버가 어떤 구성으로 실행되고 있는 지 등을 설정하지 않는다는 특징을 가지고 있습니다. 서버리스 아키텍처의 처리 방식에는 BaaS와 FaaS가 있습니다.

> BaaS(Backend as a Service)

BaaS는 서버 개발 시 필요한 데이터 베이스, 소셜 서비스 연동, 파일 시스템 등을 API로 제공해 줌으로서, 필요한 기능만을 쉽고 빠르게 구현할 수 있게 해주고, 비용은 사용한 만큼 부가됩니다. 서버 이용량이 급증하게 되더라도 자동으로 확장되기 때문에 서버 확장 작업이 필요하지 않습니다. BaaS를 제공하는 대표적인 서비스에는 FireBase, Kinvely등이 있습니다. 

> FaaS(Function as a Service) 

FaaS는 분산된 컴퓨팅 자원에 실행할 프로젝트를 여러 개의 함수로 쪼개어 등록하고, 함수 실행 횟수 만큼 비용이 부가되는 구조입니다. 함수는 콘솔을 통해 직접 호출하거나, 주기적으로 실행하도록 설정하여 호출 또는 웹 요청을 통해 호출하는 방법이 있습니다. 함수가 호출되면 서버를 준비하여 실행하기 때문에 비용이 많이 절약됩니다. FaaS의 대표적인 서비스로는 AWS Lamda, Azure Functions, Google Cloud Functions등이 있습니다. 


## 7. 백엔드 개발에서 TDD(Test-Driven Development)를 사용하면 어떤 장점이 있나요?
>Tdd란?

Test Driven Development의 약자로 테스트 주도 개발을 의미합니다. 반복 테스트를 이용한 소프트웨어 방법론으로 작은 단위의 테스트 케이스를 작성하고 이러한 테스트를 통과한 코드만을 추가하는 과정을 반복합니다. 
 
## 8. 백엔드에서 데이터베이스를 설계할 때 고려해야 할 요소는 무엇인가요?

>데이터 베이스 설계시 고려 사항

1. 무결성 : 삽입, 삭제, 갱신 등의 연산 후에도 데이터 베이스에 저장된 데이터가 정해진 제약조건을 항상 만족해야 합니다.
2. 일관성 : 데이터 베이스에 저장된 데이터들 사이나, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 합니다.
3. 회복 : 시스템에 장애가 발생했을 때, 장애 발생 직전의 상태로 복구할 수 있어야 합니다.
4. 보안 : 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호할 수 있어야 합니다.
5. 효율성 : 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 합니다.
6. 데이터 베이스 확장 : 데이터 베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 합니다

## 9. 백엔드에서 사용되는 프로세스 간 통신(IPC) 방법은 무엇이 있나요?

>공유메모리

프로세스 간의 공유된 메모리 영역에 read/write를 통해 통신을 수행하는 방법입니다. 프로세스가 공유메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당합니다. 이후 어떤 프로세스 건 해당 메모리 영역에 접근할 수 있게 됩니다. 커널 의존성이 낮기 때문에 속도가 빠르다는 장점이 있지만 자원과 데이터를 공유하기 때문에 동기화 이슈가 발생한다는 단점이 있습니다.

>메시지 전달 방법

메시지 전달 방법은 시스템 콜을 사용하여 구현됩니다. 커널을 통해 송신 메시지와 수신 메시지라는 두가지의 연산을 제공받습니다. 공유 메모리 방식보다 속도는 느리지만, 충돌을 회피하지 않아도 되기 때문에 적은 양의 데이터를 교환하는 데 유용합니다. 대표적인 방법으로는 파이프, 소켓, 메모리 큐, RPC 등이 있습니다.
 
 ## 10.  백엔드에서 사용되는 OAuth2.0이란 무엇이며, 어떤 상황에서 사용하는 것이 적합한가요
 >OAuth란?
 
 Open standard for Authorization의 약자로 사용자가 단 한번의 인가 절차로 다른 웹 서비스를 이용할 때, 로그인 자경증명을 제공하지 않고도 인증을 진행하는 개방형 표준 프로토콜 입니다. OAuth 2.0는 기술 발전으로 다양한 기기에서 인터넷 접근이 가능하게 되어 해당 환경에 맞게 변화하게 된 결과물입니다. Oauth 2.0의 인증방식에는 Authorization Code Grant, Implicit Grant, Resource Owner Password Credentials Grant, Client Credentials Grant등 4가지의 인증방식이 있습니다.
 1. Authorization Code Grant : OAuth의 서버에서 클라이언트에게 바로 Access Token을 넘겨주는 것이 아닌 Authorization Code를 넘겨준 후 클라이언트에서 Authorization Code를 사용해 Access Token을 발급받도록 하는 것입니다. Access Token이 백엔드에서만 존재하게 되어 탈취의 위험이 줄어듭니다. 
 2. Implicit Grant : Authorization Code Grant에서 진행하는 Authorization Code 교환 과정을 제외하고, 액세스 토큰을 즉시 발급받도록 하는 것입니다. 
 3. Resource Owner Password Credentials Grant : 소스 소유자 암호 자격 증명 타입 클라이언트가 암호를 사용하여 엑세스 토큰에 대한 사용자의 자격 증명을 교환하는 방식입니다.
 4. Client Credentials Grant : 클라이언트 자격 증명 타입 클라이언트가 컨텍스트 외부에서 액세스 토큰을 얻어 특정 리소스에 접근을 요청할 때 사용하는 방식입니다.

>사용이유?

서비스 이용자에게 다른 서비스의 해당 이용자의 정보를 안전하게 가져오기 위해서 사용합니다. 
