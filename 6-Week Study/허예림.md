## 1. 운영체제란 무엇인가요?
> 운영체제란?

운영체제는 컴퓨터를 동작시키는 데 도움을 주는 소프트웨어로 컴퓨터의 하드웨어와 소프트웨어 자원을 관리하는 시스템 소프트웨어 입니다. 운영체제는 하드웨어
바로 위에 설치되어 사용자 혹은 다른 응용프로그램들과 컴퓨터 하드웨어 간의 인터페이스 역할을 합니다.

> 역할

운영체제는 사용자가 컴퓨터 시스템을 편리하게 사용할 수 있는 GUI, CLI등과 같은 인터페이스를 제공합니다.
또, 하드웨어를 관리하여 컴퓨터 시스템 내의 자원을 효율적으로 관리하는 역할을 합니다.

> 목적

  1. 운영 체제를 사용하여 일정 시간 내에 시스템이 처리하는 일의 양을 향상 시킬 수 있습니다.
  2. 반환 시간을 효율적으로 관리할 수 있습니다.
  3. 신뢰도(컴퓨터가 주어진 문제를 해결하는 능력)을 향상 시킬 수 있습니다.

## 2. 클래스와 객체지향의 개념에 대해서 설명해보세요.
> 클래스란?

자바에서 클래스는 객체를 정의하는 설계도의 역할을 하고 있습니다. 객체를 생성하는 클래스를 기반으로 여러 객체를 생성하게 됩니다.

> 객체 지향이란?

객체지향이란 모든 데이터를 객체로 판단하여 객체관의 관계를 중심으로 프로그래밍 하는 프로그래밍 기법입니다.
실생활에서 존재하는 모든 것을 객체로 취급하여 객체의 상태와 행동을 구체화 하는 구조를 가집니다.

## 3. 자바 파이널 키워드 적용 시 어떤 현상이 일어나는지 설명해보세요.
> final이란

파이널은 자바에서 변수/메소드 혹은 클래스에 사용되는 키워드 입니다. final 키워드를 사용하면 처음 정의된 상태에서
변하지 않는 것을 보장하는 불변성을 확보하게 됩니다. 즉, final 키워드를 사용한 경우엔 처음 초기화한 상태에서
변경이 불가능 하다는 의미를 가집니다. 따라서 final 키워드로 한번 초기화한 변수를 이후에 값을 수정하려고 시도하면
컴파일 에러가 발생하게 됩니다. 또 final 키워드를 사용한 클래스의 경우 다른 클래스에서 상속할 수 없느 클래스가 됩니다.
마찬가지로 final 클래스를 상속하려고 할 경우에 컴파일 에러가 발생하게 됩니다. final 메서드에서도 마찬가지로
Override가 불가능하게 되며 Override 시도 시 컴파일 에러가 발생합니다.

## 4. Spring Collection에 대해서 설명해 보세요.
> Collection 이란?

컬렉션은 다수의 데이터를 하나의 그룹으로 묶어 효율적으로 저장하고, 관리하는 기능을 제공하는 클래스의 집합입니다. 
배열은 크기가 고정되어 있는 데에 반해, 컬렉션은 가변적인 크기를 갖는다는 특징을 갖습니다. 데이터 삽입, 정렬, 삭제 등 데이터의 처리와 관련된 API를 다수 제공하고 있습니다.

> 장점

1. List, Queue, Set, Map 등의 인터페이스를 제공하고, 이를 구현하는 클래스를 제공하여 일관된 API를 사용할 수 있습니다.
2. 가변적인 저장 공간을 제공합니다. 고정적인 저장 공간을 제공하는 배열에 대비되는 특징입니다.
3. 자료구조, 알고리즘을 구현하기 위한 코드를 직접 작성할 필요 없이, 이미 구현된 컬렉션 클래스를 목적에 맞게 선택하여 사용하면 됩니다. 
4. 제공되는 APU의 코드는 검증되어 있으며 고도로 최적화 되어 있습니다.
> 구성요소

1. 인터페이스 : 각 컬렉션을 나타내는 추상 데이터에 대한 인터페이스(List, Set, Map)등 클래스는 이 인터페이스를 구현하는 방식으로 작성되었기 때문에 상세 동작은 달라도 일관된 조작법으로 사용할 수 있습니다.
2. 클래스 : 컬렉션 별 인터페이스의 구현 위에서 언급했듯, 같은 List 컬렉션이더라도 목적에 따라 ArrayList, LinkedList 등으로 상세 구현이 달라질 수 있습니다.
3. 알고리즘 : 컬렉션이 제공하는 연산, 검색, 정렬, 셔플 등에 대한 메소드

> 종류

1. 리스트 : 인덱스 순서로 요소를 저장한다. 중복된 데이터를 저장할 수 있습니다.
2. 큐 : 데이터가 저장된 순서대로 출력되는 선입선출의 구조를 갖는 선형 자료구조입니다.
3. 집합 : 순서가 없으며, 데이터를 중복하여 저장할 수 없다. 집합 연산 (합집합, 교집합, 차집합 등)을 지원합니다.
4. 맵 : Key – Value 쌍으로 데이터를 저장합니다. 순서가 존재하지 않으며, Key가 중복될 수 없습니다. 

## 5. Spring AOP에 대해 설명해보세요.

> AOP란?

AOP는 Aspect Oriented Programming의 약자로 관점 지향 프로그래밍을 의미합니다. 
관점 지향은 쉽게 말해 어떤 로직을 기준을 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화 하겠다는 것 입니다. 
여기서 모듈화란 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 말합니다. 소스 코드상에서 계속 반복해서 사용되는 부분들을 흩어진 관심사라고 하는데 AOP의 관점을 기준으로 로직을 모듈화한다는 것은 흩어진 관심사를 모듈화 하겠다는 의미입니다. 즉 AOP를 사용하여 여러 개의 클래스에 걸쳐있는 function들을 독립된 클래스로 빼내서 추후에 재사용한 모듈로 만들 수 있습니다.

> 적용 방법

1. 컴파일 타임 적용 : 컴파일 시점에 바이트 코드를 조작하여 AOP가 적용된 바이트 코드를 생성하는 방법
2. 로드 타임 적용 : 순수하게 컴파일 한 뒤, 클래스를 로딩하는 시점에 클래스 정보를 변경하는 방법
3. 런타임 적용 : 스프링 AOP가 주로 사용하는 방법 A라는 클래스 타입의 Bean을 만들 때 A 타입의 Proxy Bean을 만들어 Proxy Bean이 Aspect 코드를 추가하여 동작하는 방법

> 스프링 AOP

스프링에서 제공하는 스프링 AOP는 프락시 기반의 AOP 구현체입니다.
프록시 객체를 사용하는 것은 접근 제어 및 부가 기능을 추가하기 위함입니다.
스프링 AOP는 스프링 Bean에서만  사용할 수 있습니다.
모든 AOP 기능을 제공하는 것이 목적이 아닌, 중복 코드, 프록시 클래스 작성의 번거로움 등 흔한 문제를 해결하기 위한 솔루션을 제공하는 것이 목적입니다..
스프링 AOP는 순수 자바로 구현되었기 때문에 특별한 컴파일 과정이 필요하지 않습니다.


## 6. 데이터 베이스 뷰란 무엇인가요? 어떤 경우에 사용하나요?

> 뷰란?

뷰는 하나 이상의 테이블을 조인하여 생성한 가상의 테이블을 의미합니다. 실제로 테이블이 생성되어 저장되는 것은 아니지만
실제 테이블과 거의 동일한 역할을 수행합니다. 뷰는 사용자에게 허용된 데이터만을 추출하여 보여주거나 복잡한 쿼리를 가상 테이블로
만드는 데 활용됩니다.

> 장점
  1. 데이터 조회 용이
  2. 필요한 데이터만 추출하여 제공할 수 있어 보안에 용이
  3. 물리 공간이 필요하지 않다.
  4. 실테이블의 구조가 변경되어도 뷰는 정의만 변경되는 데이터 독립성을 가진다.
  5. 응용 프로그램에 대한 영향이 없다
  6. WITH CHECKOUT OPTION을 이용하여 데이터 무결성을 유지할 수 있다.

> 단점
  1. 뷰는 인덱스를 가질 수  없다.
  2. 뷰를 활용하여 뷰를 생성한 경우 연관된 뷰가 삭제될 때 생성된 뷰도 같이 삭제된다.
  3. 수정이 불가능 하다.

## 7. 샤딩이란?

> 샤딩

샤딩은 대규모 데이터 베이스를 빠르고 쉽게 관리할 수 있도록 작게 분산하는 것을 의미하며, DB 트래픽을 분산할 수 있는 중요한 수단입니다. 
샤딩 적용 시 하나의 스키마를 다수의 복제본으로 구성하고 각각의 샤드에 어떤 데이터가 저장될지를 샤드 키를 기준으로 분리하게 됩니다.
데이터 접근 시 샤딩키를 사용하여 동적으로 DB서버를 매핑하는 과정을 거치게 됩니다. 

> 해시 샤딩

해시 함수를 사용해 샤드 키를 나누는 방식입니다. 샤드 키를 id % num을 하여 정하는 방식이며, 비교적 구현이 간단합니다. 
한번 나눌 개수를 정해 놓으면 수정하지 못하기 때문에 샤드가 늘어나게 되면 해시 함수를 재설정해야하고, 해시 함수 수정 시 기존에 저장된 샤드 키 전체를 수정해야 하기에 확장성 측면에선 효율적이지 않습니다. 
단순히 hashing 방식이기에 데이터가 저장되는 공간적 효율에 대한 고려는 따로 할 수가 없게 됩니다.
> 다이나믹 샤딩

Locator Service를 통해 샤드키를 구성하는 방식입니다. 샤드가 더 추가된다 해도 Locator Service 내 샤드키만 추가해 확장 가능합니다. Locator Service에 종속적 입니다.
> Entity Group

관련 되어있는 엔티티를 같은 파티션(샤드) 내에 저장하는 방식입니다. 
단일 샤드를 사용하기 때문에 쿼리가 효율적이며 강한 응집도를 갖습니다. 다른 샤드의 엔티티가 연관되어 있는 경우에 쿼리 사용시 비효율적 일 수 있습니다.

## 8. 해시테이블이란 무엇이며, 어떤 경우에 사용하나요?
> 해시 테이블 이란?

해시 테이블이란 키(Key) 값(Value)를 한 쌍으로 데이터를 저장하는 자료 구조입니다. 내부적으로 버킷이라 불리는 배열을 사용하여 빠른 검색 속도를 제공합니다. 
버킷이란 각각의 키(Key) 값(Value)에 해시 함수를 적용하여 배열의 index를 생성하여 index를 활용한 저장/검색을 가능하게 하고 실제 값이 저장되는 장소를 버킷(슬롯)이라고 합니다. 

> 해시 충돌

해시 테이블은 중복된 인덱스 갑이 생성되는 경우 충돌이 발생할 수 있습니다. 해시 충돌이 발생하는 경우에 테이블 내의 새로운 주소를 탐색하여 비어 있는 곳에 충돌된 데이터를 입력하는 방식인 
개방 주소법과 링크드 리스트 혹은 트리를 사용하는 분리연결법이 있습니다.
> 개방 주소법

1. 선형 탐사법 : 빈공간이 발견될 때까지 순차적으로 탐사하는 방법입니다. 특정 해시 값의 주변이 모두 채워져 있는 일차 군집화 문제에 취약하다는 단점을 가지게 됩니다. 
2. 제곱 탐사법 : 탐사하는 폭이 고정이 아닌 제곱으로 늘어나는 방법입니다. 선형 탐사법에 비해 데이터의 밀집도가 낮아지도록 저장할 수 있어 연쇄적으로 충돌이 발생할 확률이 줄어 듭니다. 
3. 이중 해싱 : 해시 함수를 이중으로 사용하는 방법입니다. 하나는 최초 해시를 얻을 때 사용하고, 또 다른 해시는 충돌이 났을 경우 탐사 이동 폭을 얻기 위해 사용하는 방법입니다. 최초 해시로 같은 값이 나오더라도 다른 해시 함수를 거치면서 다른 탐사 이동폭을 제공하기 때문에 다른 공간에 값이 골고루 저장될 확률이 높아 집니다. 


## 9. 모놀리식 아키텍처와 마이크로서비스 아키텍처의 차이점은 무엇인가요?
> 모놀리식 아키텍처란?

모놀리식 아키텍처는 소프트웨어 혹은 서비스가 하나의 거대한 아키텍처를 갖는 구조를 의미합니다.
전통의 아키텍처를 지칭하는 의미로 내부 요소가 한 프로젝트에 통합되어 있어 의존성이 강하다는 특징이 있습니다. 모놀리식 아키텍처는 모든 비즈니스 컴포넌트 들이 긴밀히 결합하여 단일 서비스로 실행됩니다.

> 마이크로 서비스 아키텍처

마이크로 서비스 아키텍처는 하나의 서비스 혹은 소프트웨어를 상호 독립적인 최소 구성요소로 분할한 구조입니다. 모든 요소가 독립적이며 연동되어 동일한 태스크를 완수합니다. 
업데이트, 테스트, 배포 및 확장은 각 서비스 내에서 이루어집니다. 마이크로 서비스는 주요 비즈니스, 도메인 별 문제를 별도의 독립적인 코드 베이스로 분리합니다. 
마이크로 서비스는 복잡성을 줄여주지는 않지만, 작업이 서로 독립적으로 작동하고 전체에 기여하는 더 작은 프로세스로 분리하여 복잡성을 눈으로 볼 수 있고 관리하기 쉽도록 만듭니다. 
마이크로 서비스 채택은 팀이 사용자 요구사항에 빠르게 적응할 수 있도록 지속적 배포 관행의 기반이기 때문에 Devops 채택과 함께 이루어 지는 경우가 많습니다.


