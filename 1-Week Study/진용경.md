# 1. 자바의 특징
     자바의 장점
     - 운영체제에 독립적이다. ( JVM에서 동작하기 때문 )
     - 객체지향 언어이다. ( 캡슐화, 상속, 추상화, 다형성 )
     - 자동으로 메모리를 괸리해준다. ( JVM에 Garbage Collector에 의해 GC(Garbage Collection)가 일어나 그로 인해 별도의 메모리 관리가 필요 없다. )
     - 오픈소스이다. ( 정확히는 OpenJDK가 오픈소스이다. )
     - 멀티스레드를 쉽게 구현할 수 있다.
     - 동적 로딩을 지원한다. ( 애플리케이션이 실행될 때 모든 객체가 생성되는 것이 아니라, 
                              각 객체가 필요한 시점에 클래스를 동적 로딩하여 생성한다. 
                              따라서, 유지보수가 쉽고 빠르다 )
    
    자바의 단점
     - 비교적 속도가 느리다. ( JVM에 의해 기계어로 번역되고 실행하는 과정을 거치기 때문에 C나 C++에 비해 속도가 느리다. )
     - 예외처리가 불편하다.

    java의 접근 제어자
    - public : 모든 클래스의 객체에서 접근 가능
    - private : 해당 클래스에서 생성된 객체들만 접근 가능
    - protected : 해당 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 객체들만 접근 가능
    - package : 동일 패키지에 있는 클래스의 객체들만 접근 가능


# 2. 가비지 컬렉션이란?
    - GC == Garbage Collection
        ->  JVM의 Heap 영역에서 사용하지 않는 객체를 삭제하는 프로세스를 말한다.
            -> Heap 영역에는 Object 타입의 데이터들이 들어간다. ( String, List 또는 우리가 만든 custom 클래스들 )
        -> Heap 영역에서 사용하지 않는지를 어떻게 알고 삭제하는가?
            -> GC Roots 에서 하나씩 탐색해 나가서 어떤 객체에 유효한 참조간 존재한다면 Reachable, <-> 그렇지 않다면 Unreachable이라고 한다. (root에서 끊겨있다) 
            -> JVM의 Heap 영역에 존재하는 객체가 Stack 영역이나 Method Area 에서 참조되고있다면 Reachable 하다고 한다.
            -> 그 어디서도 참조되고있지 않은 객체는 Unreachable 객체라고 하고 GC의 수거 대상이 된다.
    - GC의 동작 순서
        -> Mark and Sweep
            => Mark : gc Root로부터 모든 변수를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다.
            => Sweep : Unreachable 객체들을 Heap영역에서 제거한다.
            단점 : 의도적을 GC를 실행시켜야 한다. / 어플리케이션 실행과 GC 실행이 병행된다.
    - Heap의 구조
        -> Heap은 Young Generation과 Old Generation으로 구분된다.
            => Young Generation : 새로운 객체들이 할당되는 영역 (Eden, Survivor0, Survivor1로 구분)
                => Eden : 새로운 객체가 Eden 영역에 할당된다. -> Eden 영역에 더이상 할당될 공간이 없다면 Minor GC가 발생한다 -> Mark and Sweep 과정이 발생
                => Survivor0 : 위 Mark and Sweep 과정에서 살아남은 객체들이 이동하여 할당되는 영역
                => Survivor1 : Survivor0에 객체들이 존재한다면 Survivor1은 비워져 있어야하며, 반대로 Survivor1에 객체들이 존재한다면 Survivor0은 빈 공간이어야 한다.
                    -> Sweep 과정을 통해 살아남은 Reachable객체들은 Survivor 영역으로 할당되고, 해당 영역에 있는 객체들은 age가 증가한다.(==Aging)
                    -> Minor GC가 발생할 때마다 살아남은 객체들은 Survivor영역을 왔다갔다 하며 age값이 증가한다.
                    이떄, age값이 특정 임계점 (==age threshold)에 도달하면 Old Generation으로 이동한다. (==Promotion)
                        => Old Generation이 꽉 차면 Major GC가 발생한다.
            => Old Generation : Young Generation에서 오랫동안 살아남은 객체들이 존재하는 영역
    - stop-the-world
        -> GC를 실행하기 위해 JVM이 어플리케이션 실행을 멈추는 것
            => GC를 실행하는 쓰레드 외의 모든 쓰레드가 작업을 중단한다. (GC의 종류마다 stop-the-world의 소요 시간이 다르다.)
    - GC의 종류
        - Serial GC
        - Parallel GC
        - Parallel Old GC
        - CMS GC
        - G1 GC

# 3. 오버로딩과 오버라이딩의 차이 +오버라이딩의 사용조건
    - Overriding
        : 임의의 클래스가 다른 클래스를 상속 받거나 인터페이스를 구현했을 때, 상위 클래스 또는 인터페이스에 정의되어 있는 메소드를 재정의 하여 사용하는 것이다. 
          메소드 호출 시 재정의되어 있지 않다면 상위 클래스의 메소드가 호출된다. (인터페이스는 오버라이딩이 강제된다.)
    - Overloading
        : 메소드에 주어진 인자(parameter)에 따라 동작을 다르게 구현할 수 있다. 코드의 중복이 줄어들고, 가독성이 늘어난다. 
          반환 형(return type)은 관계가 없지만, 인자의 개수, 인자의 타입에 따라 다르게 구현할 수 있다.

# 4. 객체지향프로그래밍(OOP)에 대해서 설명해주세요
    - 객체지향 프로그래밍
        -> 각자의 역할을 지닌 객체들끼리 서로 메시지를 주고받으며 동작할 수 있도록 프로그래밍 하는 것
            => 객체
                : 현실세계의 실체 및 개념을 반영하는 상태와 행위를 정의한 데이터의 집합

    - OOP의 4가지 특징
        1. 추상화 (Abstraction)
            : 구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념으로 다루는 것
        2. 캡슐화 (Encapsulation)
            : 정보 은닉 -> 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것
            : 높은 응집도, 낮은 결합도를 유지하여 유연함과 유지보수성 증가
        3. 상속
            : 여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정
        4. 다형성
            : 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력
            : 오버라이딩, 오버로딩

# 5. SOLID원칙에 대해서 설명해주세요
    - OOP의 5대 원칙 : SOLID 원칙
        -> S : 단일 책임 원칙 (SPR, Single Responsibility Principle)
            => 객체는 단 하나의 책임만 가져야 한다.
        -> O : 개방-폐쇄 원칙 (OCP, Open Closed Principle)
            => 기존의 코드를 변경하지 안히으면서 기능을 추가할 수 있도록 설계가 되어야 한다.
        -> L : 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)
            => 일반화 관계(상속)에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
        -> I : 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)
            => 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
        -> D : 의존 역전 원칙 (DIP, Dependency Inversion Principle)
            => 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다.


# 6. 동일성과 동등성의 차이


# 7. OSI 7계층이란?

