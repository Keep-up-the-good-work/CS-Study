# 1. 자바의 특징
     자바의 장점
     - 운영체제에 독립적이다. ( JVM에서 동작하기 때문 )
     - 객체지향 언어이다. ( 캡슐화, 상속, 추상화, 다형성 )
     - 자동으로 메모리를 괸리해준다. ( JVM에 Garbage Collector에 의해 GC(Garbage Collection)가 일어나 그로 인해 별도의 메모리 관리가 필요 없다. )
     - 오픈소스이다. ( 정확히는 OpenJDK가 오픈소스이다. )
     - 멀티스레드를 쉽게 구현할 수 있다.
     - 동적 로딩을 지원한다. ( 애플리케이션이 실행될 때 모든 객체가 생성되는 것이 아니라, 
                              각 객체가 필요한 시점에 클래스를 동적 로딩하여 생성한다. 
                              따라서, 유지보수가 쉽고 빠르다 )
    
    자바의 단점
     - 비교적 속도가 느리다. ( JVM에 의해 기계어로 번역되고 실행하는 과정을 거치기 때문에 C나 C++에 비해 속도가 느리다. )
     - 예외처리가 불편하다.

    java의 접근 제어자
    - public : 모든 클래스의 객체에서 접근 가능
    - private : 해당 클래스에서 생성된 객체들만 접근 가능
    - protected : 해당 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 객체들만 접근 가능
    - package : 동일 패키지에 있는 클래스의 객체들만 접근 가능


# 2. 가비지 컬렉션이란?
    - GC == Garbage Collection
        ->  JVM의 Heap 영역에서 사용하지 않는 객체를 삭제하는 프로세스를 말한다.
            -> Heap 영역에는 Object 타입의 데이터들이 들어간다. ( String, List 또는 우리가 만든 custom 클래스들 )
        -> Heap 영역에서 사용하지 않는지를 어떻게 알고 삭제하는가?
            -> GC Roots 에서 하나씩 탐색해 나가서 어떤 객체에 유효한 참조간 존재한다면 Reachable, <-> 그렇지 않다면 Unreachable이라고 한다. (root에서 끊겨있다) 
            -> JVM의 Heap 영역에 존재하는 객체가 Stack 영역이나 Method Area 에서 참조되고있다면 Reachable 하다고 한다.
            -> 그 어디서도 참조되고있지 않은 객체는 Unreachable 객체라고 하고 GC의 수거 대상이 된다.
    - GC의 동작 순서
        -> Mark and Sweep
            => Mark : gc Root로부터 모든 변수를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다.
            => Sweep : Unreachable 객체들을 Heap영역에서 제거한다.
            단점 : 의도적을 GC를 실행시켜야 한다. / 어플리케이션 실행과 GC 실행이 병행된다.
    - Heap의 구조
        -> Heap은 Young Generation과 Old Generation으로 구분된다.
            => Young Generation : 새로운 객체들이 할당되는 영역 (Eden, Survivor0, Survivor1로 구분)
                => Eden : 새로운 객체가 Eden 영역에 할당된다. -> Eden 영역에 더이상 할당될 공간이 없다면 Minor GC가 발생한다 -> Mark and Sweep 과정이 발생
                => Survivor0 : 위 Mark and Sweep 과정에서 살아남은 객체들이 이동하여 할당되는 영역
                => Survivor1 : Survivor0에 객체들이 존재한다면 Survivor1은 비워져 있어야하며, 반대로 Survivor1에 객체들이 존재한다면 Survivor0은 빈 공간이어야 한다.
                    -> Sweep 과정을 통해 살아남은 Reachable객체들은 Survivor 영역으로 할당되고, 해당 영역에 있는 객체들은 age가 증가한다.(==Aging)
                    -> Minor GC가 발생할 때마다 살아남은 객체들은 Survivor영역을 왔다갔다 하며 age값이 증가한다.
                    이떄, age값이 특정 임계점 (==age threshold)에 도달하면 Old Generation으로 이동한다. (==Promotion)
                        => Old Generation이 꽉 차면 Major GC가 발생한다.
            => Old Generation : Young Generation에서 오랫동안 살아남은 객체들이 존재하는 영역
    - stop-the-world
        -> GC를 실행하기 위해 JVM이 어플리케이션 실행을 멈추는 것
            => GC를 실행하는 쓰레드 외의 모든 쓰레드가 작업을 중단한다. (GC의 종류마다 stop-the-world의 소요 시간이 다르다.)
    - GC의 종류
        - Serial GC
        - Parallel GC
        - Parallel Old GC
        - CMS GC
        - G1 GC

# 3. 오버로딩과 오버라이딩의 차이 +오버라이딩의 사용조건
    - Overriding
        : 임의의 클래스가 다른 클래스를 상속 받거나 인터페이스를 구현했을 때, 상위 클래스 또는 인터페이스에 정의되어 있는 메소드를 재정의 하여 사용하는 것이다. 
          메소드 호출 시 재정의되어 있지 않다면 상위 클래스의 메소드가 호출된다. (인터페이스는 오버라이딩이 강제된다.)
    - Overloading
        : 메소드에 주어진 인자(parameter)에 따라 동작을 다르게 구현할 수 있다. 코드의 중복이 줄어들고, 가독성이 늘어난다. 
          반환 형(return type)은 관계가 없지만, 인자의 개수, 인자의 타입에 따라 다르게 구현할 수 있다.

# 4. 객체지향프로그래밍(OOP)에 대해서 설명해주세요
    - 객체지향 프로그래밍
        -> 각자의 역할을 지닌 객체들끼리 서로 메시지를 주고받으며 동작할 수 있도록 프로그래밍 하는 것
            => 객체
                : 현실세계의 실체 및 개념을 반영하는 상태와 행위를 정의한 데이터의 집합

    - OOP의 4가지 특징
        1. 추상화 (Abstraction)
            : 구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념으로 다루는 것
        2. 캡슐화 (Encapsulation)
            : 정보 은닉 -> 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것
            : 높은 응집도, 낮은 결합도를 유지하여 유연함과 유지보수성 증가
        3. 상속
            : 여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정
        4. 다형성
            : 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력
            : 오버라이딩, 오버로딩

# 5. SOLID원칙에 대해서 설명해주세요
    - OOP의 5대 원칙 : SOLID 원칙
        -> S : 단일 책임 원칙 (SPR, Single Responsibility Principle)
            => 객체는 단 하나의 책임만 가져야 한다.
        -> O : 개방-폐쇄 원칙 (OCP, Open Closed Principle)
            => 기존의 코드를 변경하지 안히으면서 기능을 추가할 수 있도록 설계가 되어야 한다.
        -> L : 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)
            => 일반화 관계(상속)에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
        -> I : 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)
            => 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
        -> D : 의존 역전 원칙 (DIP, Dependency Inversion Principle)
            => 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다.


# 6. 동일성과 동등성의 차이
    - 동일성(Identity)
        -> 동일성은 두 객체가 완전히 같은 경우이다. 즉, 각 변수에 저장된 객체의 주소가 같은지를 비교한다. 
           자바에서는 항등 연산자 '==' 을 사용한다.
           참조 비교 : 두 객체가 같은 메모리 공간을 가리키는지 확인한다.
           반환 형태 : boolean type, 같은 주소면 true를 그렇지 않으면 false를 반환한다.

    - 동등성(Equality)
        -> 동등성은 두 객체에 저장된 값이 같은 값인 경우를 의미한다. 동일성과는 다르게 객체의 주소가 서로 다르더라도 값이 같다면 두 변수는 동등하다고 이야기한다.
           자바에서는 객체 비교 메소드 'equals()'를 사용한다.
           내용 비교 : 두 객체의 값이 같은지 확인한다.
           반환 형태 : boolean type, 같은 값이면 true, 그렇지 않으면 false를 반환한다.

    => 동일하면 동등하다고 할 수 있지만 동등하다고 동일한 것은 아니다.


# 7. OSI 7계층이란?
    - OSI (Open Systems Interconnection Reference Model)
        -> 국제표준화기구(ISO)에서 개발한 모델로, 프로토콜을 기능별로 나눈 것이다.
        -> 일반적으로 하위 계층들은 하드웨어, 상위 계층들은 소프트웨어로 구현된다.

    1. 물리 계층 (Physical layer)
        -> 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다.
        -> 네트워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층이다.
        -> 전송 단위는 Bit이다.

    2. 데이터 링크 계층 (Data link layer)
        -> point to point 간 신뢰성 있는 전송을 보장하기 위한 계층으로 CRC기반의 오류 제어와 흐름 제어가 필요하다.
        -> 주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 MAC adrres가 정해져 있다는 뜻이다.
        -> 대표적인 예로는 이더넷이 있다.
        -> 데이터 전송 단위는 frame이다.

    3. 네트워크 계층 (Network layer)
        -> 여러개의 노드를 거칠때마다 경로는 찾아주는 역할을 하는 계층이며, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)을 제공하기 위한 기능적, 절차적 수단을 제공한다.
        -> 라우팅, 흐름 제어, 세그멘테이션, 오류 제어, internetworking 등을 수행한다.
        -> IP, 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적(hierarchical)이다.
        -> 데이터 전송 단위는 Datagram(Packet)이다.

    4. 전송 계층 (Transport layer)
        -> 양 끝단(end to end)의 사용자들이 신뢰성 있는 데이터를 주고 받을 수 있도록 해주며, 상위 계층들이 데이터 전달의 유효성/효율성을 생각하지 않도록 해준다.
        -> 시퀀스 넘버 기반의 오류 제어 방식을 사용한다.
        -> 전송 계층은 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들은 다시 전송한다.
        -> 대표적인 예로는 TCP가 있다.
        -> 데이터 전송 단위는 Segment이다.

    5. 세션 계층 (Session layer)
        -> 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
        -> duplex, half-duplex, full-duplex 방식의 통신과 함께 체크포인팅과 유휴, 종료, 재시작 과정 등을 수행한다.
        -> TCP/IP 세션을 만들고 없애는 책임을 진다.

    6. 표현 계층 (Presentation layer)
        -> 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다.
        -> MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.

    7. 응용 계층 (Application layer)
        -> 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.
        -> 일반적인 응용 서비스는 관련된 응용 프로세스들 사이의 전환을 제공한다.

